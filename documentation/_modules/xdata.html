<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>xdata &#8212; Xplor your data</title>
    
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../_static/favicon1.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Xplor your data</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for xdata</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;xdata module is a module to define a structure to store the data in the</span>
<span class="sd">form of an N dimensional array as well as the description of the data and each</span>
<span class="sd">of the dimensions (names, types, units, scale, ...)</span>


<span class="sd">This module uses: </span>
<span class="sd">    - pandas as pd</span>
<span class="sd">    - numpy as np</span>
<span class="sd">    - operator</span>
<span class="sd">    - abc</span>


<span class="sd">There are 6 classes in this module:</span>
<span class="sd">    </span>
<span class="sd">    - **Color**:</span>
<span class="sd">        This class allows defining colors, either as RGB values or using</span>
<span class="sd">        predefined strings.</span>

<span class="sd">    - **DimensionDescription**:</span>
<span class="sd">        For a specific dimension, DimensionDescription stores a label,a</span>
<span class="sd">        dimension_type (&#39;numeric&#39;, &#39;logical&#39;, &#39;string&#39;, or &#39;mixed&#39;), possibly a</span>
<span class="sd">        unit and the corresponding conversion table.</span>
<span class="sd">        It allows to determine the dimension_type of an element, and access the</span>
<span class="sd">        default value of a given dimension_type.</span>
<span class="sd">                        </span>
<span class="sd">    - **Header**:</span>
<span class="sd">        Abstract class (subclasses are CategoricalHeader and MeasureHeader).</span>
<span class="sd">        Headers contains information about a dimension of the NDimensional</span>
<span class="sd">        data, such as a general label, the number of element, the description</span>
<span class="sd">        of the dimension/subdimensions, and allows to access the values to</span>
<span class="sd">        display on the axis.</span>
<span class="sd">               </span>
<span class="sd">    - **CategoricalHeader**:</span>
<span class="sd">        CategoricalHeader is a subclass of Header. It is used to characterize</span>
<span class="sd">        a dimension in which the data has no regular organisation. It usually</span>
<span class="sd">        is a list of elements. However, such elements can have interesting</span>
<span class="sd">        features of different types. That&#39;s why such features are stored in</span>
<span class="sd">        columns, each of them described by a DimensionDescription object.</span>
<span class="sd">                          </span>
<span class="sd">    - **MeasureHeader**:</span>
<span class="sd">        MeasureHeader is a subclass of Header. It is used for data acquired by</span>
<span class="sd">        equally spaced sample in a continuous dimension such as time or space.</span>
<span class="sd">        In which case, there is only one subdimension (i.e. only one column).</span>
<span class="sd">                      </span>
<span class="sd">    - **Xdata**:</span>
<span class="sd">        Xdata is used to store the data. Xdata is a container for an ND</span>
<span class="sd">        (N dimensional) array with all the values/data, as well as all of the</span>
<span class="sd">        headers describing each of the N dimensions, stored in a list. Xdata</span>
<span class="sd">        also has the name of the whole set of data and a data_descriptor</span>
<span class="sd">        attribute to describe the data.</span>

<span class="sd">There are 2 functions in this class:</span>
<span class="sd">    - **create_dimension_description**:</span>
<span class="sd">        create_dimension_description gives an instance of the class</span>
<span class="sd">        DimensionDescription from a label and an column of values of type</span>
<span class="sd">        pandas.core.series.Series.</span>
<span class="sd">    - **check_bank_unit**:</span>
<span class="sd">        The functions checks if this unit is in one of the conversion tables of</span>
<span class="sd">        the bank. If so, it returns the conversion table, else, it returns None</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Authors: Elodie Ikkache CNRS &lt;elodie.ikkache@student.ecp.fr&gt;</span>
<span class="c1">#          Thomas Deneux CNRS &lt;thomas.deneux@unic.cnrs-gif.fr&gt;</span>
<span class="c1">#</span>
<span class="c1"># version 1.0</span>
<span class="c1"># -*- coding: utf-8 -*-</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="c1"># Header is abstract, subclasses are MeasureHeader and CategoricalHeader</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="k">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="c1"># itemgetter is used to sort a list of dictionaries</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="k">import</span> <span class="n">itemgetter</span>
<span class="kn">from</span> <span class="nn">pprint</span> <span class="k">import</span> <span class="n">pprint</span>


<div class="viewcode-block" id="Color"><a class="viewcode-back" href="../xdata.html#xdata.Color">[docs]</a><span class="k">class</span> <span class="nc">Color</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Defines colors.</span>

<span class="sd">    This class allows defining colors, either as RGB values or using</span>
<span class="sd">    predefined strings.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">    - rgb:</span>
<span class="sd">        Either a 3-tuple with 3 integers between 0 and 255, or a predefined</span>
<span class="sd">        string. Predefined strings are &#39;black&#39;, &#39;white&#39;, &#39;red&#39;, &#39;green&#39;,</span>
<span class="sd">        &#39;blue&#39;, &#39;yellow&#39;, &#39;cyan&#39;, &#39;magenta&#39;</span>

<span class="sd">    **Attributes**</span>

<span class="sd">    - rgb:</span>
<span class="sd">        3-tuple with 3 integers between 0 and 255</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rgb</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rgb</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">rgb</span> <span class="o">==</span> <span class="s1">&#39;black&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">rgb</span> <span class="o">==</span> <span class="s1">&#39;white&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="p">[</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">rgb</span> <span class="o">==</span> <span class="s1">&#39;red&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="p">[</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">rgb</span> <span class="o">==</span> <span class="s1">&#39;green&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">rgb</span> <span class="o">==</span> <span class="s1">&#39;blue&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">rgb</span> <span class="o">==</span> <span class="s1">&#39;yellow&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="p">[</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">rgb</span> <span class="o">==</span> <span class="s1">&#39;cyan&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">rgb</span> <span class="o">==</span> <span class="s1">&#39;magenta&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="p">[</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;String argument is not a recognized color &quot;</span>
                                <span class="s2">&quot;name.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">rgb</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rgb</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rgb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;int out of range&quot;</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Argument must be either a 3-element color &quot;</span>
                                <span class="s2">&quot;definition or a string color name.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rgb</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">rgb</span></div>


<div class="viewcode-block" id="DimensionDescription"><a class="viewcode-back" href="../xdata.html#xdata.DimensionDescription">[docs]</a><span class="k">class</span> <span class="nc">DimensionDescription</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot; This class aims at defining a dimension.</span>
<span class="sd">    </span>
<span class="sd">    This class allows to define a dimension with a name, a type (&#39;numeric,</span>
<span class="sd">    &#39;logical&#39;, &#39;string&#39;, &#39;color&#39; or &#39;mixed&#39;), and possibly a unit for </span>
<span class="sd">    numerical dimensions.</span>
<span class="sd">    </span>
<span class="sd">    **Parameters**</span>

<span class="sd">    - label:</span>
<span class="sd">        name for the dimension</span>
<span class="sd">        (type str (e.g. &#39;time&#39;))</span>
<span class="sd">    - dimension_type:</span>
<span class="sd">        can be &#39;numeric&#39;, &#39;logical&#39;, &#39;string&#39;, &#39;color&#39; or &#39;mixed&#39;</span>
<span class="sd">    - unit:</span>
<span class="sd">        One can define only the unit (e.g. mm) or the conversions as well in</span>
<span class="sd">        the form of a list (e.g. [&#39;mm&#39;, 10**(-3), &#39;m&#39;, 1]).</span>
<span class="sd">        </span>
<span class="sd">        (type str or list)</span>
<span class="sd">        </span>
<span class="sd">        optional (default value = None)</span>
<span class="sd"> </span>
<span class="sd">    </span>
<span class="sd">    **Attributes**</span>

<span class="sd">    - label:</span>
<span class="sd">        name of the dimension</span>
<span class="sd">        (type str)</span>
<span class="sd">    - dimension_type:</span>
<span class="sd">        &#39;numeric&#39;, &#39;logical&#39;, &#39;string&#39;, &#39;color&#39; or &#39;mixed&#39;</span>
<span class="sd">    - unit:</span>
<span class="sd">        currently used unit</span>
<span class="sd">        (type str)</span>
<span class="sd">    - all_units:</span>
<span class="sd">        list of dictionaries for unit conversions</span>

<span class="sd">    **Methods**</span>

<span class="sd">    - set_dimtype_to_mixed:</span>
<span class="sd">        changing the dimension_type to &#39;mixed&#39; if adding values that are not</span>
<span class="sd">        of the correct dimension_type (merging lines for instance)</span>
<span class="sd">    - copy:</span>
<span class="sd">        to copy a DimensionDescription instance</span>
<span class="sd">        </span>
<span class="sd">    *(static methods)*</span>

<span class="sd">    - infertype(x, getdefaultvalue=False):</span>
<span class="sd">        gives the dimension_type of the x element and possibly the associated</span>
<span class="sd">        defaultvalue</span>
<span class="sd">    - defaultvalue(dimension_type):</span>
<span class="sd">        gives the default value associated to a certain dimension_type</span>
<span class="sd">        </span>
<span class="sd">    **Examples**</span>

<span class="sd">    </span>
<span class="sd">     t = DimensionDescription(&#39;time&#39;,&#39;numeric&#39;,[&#39;s, 1, &#39;ms&#39;, 10**(-3),</span>
<span class="sd">     &#39;min&#39;, 60, &#39;hour&#39;, 3600])</span>
<span class="sd">    </span>
<span class="sd">     c = DimensionDescription(&#39;condition&#39;,&#39;string&#39;)</span>
<span class="sd">     </span>
<span class="sd">    **Note**</span>
<span class="sd">     </span>
<span class="sd">    Values corresponding to a DimensionDescription of dimension_type</span>
<span class="sd">    &#39;color&#39; are Color objects</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">label</span><span class="p">,</span>
                 <span class="n">dimension_type</span><span class="p">,</span>
                 <span class="n">unit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructor of the class DimensionDescription&quot;&quot;&quot;</span>

        <span class="c1"># Checking arguments and setting properties.</span>

        <span class="c1"># label must be a string</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;label must be a string&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_label</span> <span class="o">=</span> <span class="n">label</span>

        <span class="c1"># dimension_type must be &#39;numeric&#39;, &#39;logical&#39;, &#39;string, or &#39;mixed&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">dimension_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;numeric&#39;</span><span class="p">,</span> <span class="s1">&#39;logical&#39;</span><span class="p">,</span> <span class="s1">&#39;string&#39;</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;mixed&#39;</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;a dimension_type must be &#39;numeric&#39;, &#39;logical&#39;,&quot;</span>
                            <span class="s2">&quot;&#39;string&#39;, &#39;color&#39; or &#39;mixed&#39;&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dimension_type</span> <span class="o">=</span> <span class="n">dimension_type</span>

        <span class="c1"># only &#39;numeric&#39; dimensions can have a unit, and this is not mandatory</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unit</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_all_units</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">dimension_type</span> <span class="o">!=</span> <span class="s1">&#39;numeric&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;only numeric DimensionDescriptions can have a&quot;</span>
                            <span class="s2">&quot; unit&quot;</span><span class="p">)</span>
        <span class="c1"># the unit can be given in the form of a string ...</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unit</span> <span class="o">=</span> <span class="n">unit</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_all_units</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;unit&#39;</span><span class="p">:</span> <span class="n">unit</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">}]</span>
        <span class="c1"># ...or in the form of a list of linked units and conversion</span>
        <span class="c1"># coefficients</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">unit</span><span class="p">:</span>  <span class="c1"># pythonic way of checking whether a list is empty,</span>
            <span class="c1"># by using the implicit booleanness</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;there must be at least one unit&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">list_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">list_length</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;unit must be a string with the unit symbol or&quot;</span>
                                <span class="s2">&quot; a list of the symbols of the unit followed&quot;</span>
                                <span class="s2">&quot;by the conversion indicator&quot;</span>
                                <span class="s2">&quot; (e.g. [&#39;mm&#39;, 10**(-3), &#39;m&#39;, 1]&quot;</span><span class="p">)</span>
            <span class="c1"># One of the units must be the reference.</span>
            <span class="c1"># That means that one conversion coefficient must be equal to one.</span>
            <span class="n">reference</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_all_units</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">list_length</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="c1"># assign pairs of items to unit (string) and value (float)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;unit&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">unit</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">unit</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])}</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;unit name must be a string and conversion&quot;</span>
                                    <span class="s2">&quot; coefficient must be a numerical scalar&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_all_units</span> <span class="o">+=</span> <span class="p">[</span><span class="n">d</span><span class="p">]</span>
                <span class="c1"># take the first unit with value 1 has reference</span>
                <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">reference</span><span class="p">:</span>
                    <span class="n">reference</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_unit</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;unit&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">reference</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;one of the conversion coefficients must be &quot;</span>
                                <span class="s2">&quot;equal to one to define a reference&quot;</span><span class="p">)</span>
            <span class="c1"># sort the list of units according conversion coefficients</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_all_units</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="s1">&#39;value&#39;</span><span class="p">))</span>
        <span class="c1"># Checking if the type of unit is either str, list or if it is None.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;unit must be a string with the unit symbol or a &quot;</span>
                            <span class="s2">&quot;list  of the symbols of the unit followed by &quot;</span>
                            <span class="s2">&quot;the conversion indicator (e.g. &quot;</span>
                            <span class="s2">&quot;[&#39;mm&#39;, 10**(-3), &#39;m&#39;, 1])&quot;</span><span class="p">)</span>

    <span class="c1"># Attributes label, dimension_type, unit and all_units can be seen but not</span>
    <span class="c1"># modified outside of the class (only get methods, no setters).</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;name for the dimension (type str (e.g. &#39;time&#39;))&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimension_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;&#39;numeric&#39;, &#39;logical&#39;, &#39;string&#39;, &#39;color&#39; or &#39;mixed&#39;&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimension_type</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;currently used unit (type str)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unit</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">all_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;conversion table (type list of dict)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_units</span>

    <span class="k">def</span> <span class="nf">set_dimtype_to_mixed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;change the dimension_type to mixed&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dimension_type</span> <span class="o">=</span> <span class="s1">&#39;mixed&#39;</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;copy a DimensionDescription instance&quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">DimensionDescription</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension_type</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unit</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_all_units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_units</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">infertype</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">getdefaultvalue</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;infertype is a static method to access the dimension_type of an</span>
<span class="sd">        element x and if required, the associated default value&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="n">dimtype</span> <span class="o">=</span> <span class="s1">&#39;logical&#39;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">dimtype</span> <span class="o">=</span> <span class="s1">&#39;string&#39;</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">]:</span>
            <span class="n">dimtype</span> <span class="o">=</span> <span class="s1">&#39;numeric&#39;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Color</span><span class="p">):</span>
            <span class="n">dimtype</span> <span class="o">=</span> <span class="s1">&#39;color&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dimtype</span> <span class="o">=</span> <span class="s1">&#39;mixed&#39;</span>
        <span class="k">if</span> <span class="n">getdefaultvalue</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dimtype</span><span class="p">,</span> <span class="n">DimensionDescription</span><span class="o">.</span><span class="n">defaultvalue</span><span class="p">(</span><span class="n">dimtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dimtype</span>

    <span class="c1"># Calculating a default value for the different dimension_types.</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">defaultvalue</span><span class="p">(</span><span class="n">dimension_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;defaultvalue is a static method to access the default value of a</span>
<span class="sd">        given dimension_type&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dimension_type</span> <span class="o">==</span> <span class="s1">&#39;numeric&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">dimension_type</span> <span class="o">==</span> <span class="s1">&#39;logical&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">dimension_type</span> <span class="o">==</span> <span class="s1">&#39;string&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&#39;</span>
        <span class="k">elif</span> <span class="n">dimension_type</span> <span class="o">==</span> <span class="s1">&#39;color&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Color</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">149</span><span class="p">,</span> <span class="mi">182</span><span class="p">))</span>
            <span class="c1"># it is a nice color, different from that of the background</span>
        <span class="k">elif</span> <span class="n">dimension_type</span> <span class="o">==</span> <span class="s1">&#39;mixed&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;This function only gives the default value for&quot;</span>
                            <span class="s2">&quot; the following types: &#39;numeric&#39;, &#39;logical&#39;, &quot;</span>
                            <span class="s2">&quot;&#39;string&#39;, &#39;color&#39; or &#39;mixed&#39;&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Header"><a class="viewcode-back" href="../xdata.html#xdata.Header">[docs]</a><span class="k">class</span> <span class="nc">Header</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This abstract class allows the creation of headers for the different </span>
<span class="sd">    dimensions of a dataset.</span>
<span class="sd">    </span>
<span class="sd">    Header is an abstract class that has two subclasses: CategoricalHeader and</span>
<span class="sd">    MeasureHeader.</span>
<span class="sd">    A Header object fully describes a dimension.</span>
<span class="sd">    A CategoricalHeader is used for data with  no regular organisation.</span>
<span class="sd">    It usually correspond to a list of elements. However,  such elements can</span>
<span class="sd">    have interesting features of different types. That&#39;s why such features are </span>
<span class="sd">    stored in columns, each of them described by a DimensionDescription object.</span>
<span class="sd">    A MeasureHeader is used for data acquired with regular intervals in a</span>
<span class="sd">    continuous dimension such as time or space. In which case, there is only</span>
<span class="sd">    one subdimension (i.e. only one column witch is not stored).</span>

<span class="sd">     </span>
<span class="sd">    **Attributes**</span>

<span class="sd">    - label:</span>
<span class="sd">        name of the dimension (type str)</span>
<span class="sd">    - column_descriptors:</span>
<span class="sd">        list of the DimensionDescription of each of the columns of values</span>
<span class="sd">    - is_measure:</span>
<span class="sd">        true if the header is a MeasureHeader instance, false if it is a</span>
<span class="sd">        CategoricalHeader instance</span>
<span class="sd">    - is_categorical_with_values:</span>
<span class="sd">        true if it is an instance of CategoricalHeader and that values is not</span>
<span class="sd">        None. If it is a categorical header but with no column or a measure</span>
<span class="sd">        header, it is false.</span>
<span class="sd">    - is_undifferentiated:</span>
<span class="sd">        true if it is a categorical header with no values</span>
<span class="sd">        (not is_categorical_with_values)</span>

<span class="sd">    **Methods**</span>

<span class="sd">    *(abstract methods)*</span>
<span class="sd">    </span>
<span class="sd">    - n_elem:</span>
<span class="sd">        number of element in the column(s)/ number of samples</span>
<span class="sd">    - is_categorical:</span>
<span class="sd">        differentiate measure and categorical headers for the properties</span>
<span class="sd">        is_measure, is_categorical_with_values and is_undifferentiated</span>
<span class="sd">    - __eq__:</span>
<span class="sd">        compares all the fields of the headers (returns True if all the </span>
<span class="sd">        fields are the same) it can be used by writing header1 == header2</span>
<span class="sd">    - get_n_columns:</span>
<span class="sd">        gives the number of columns (1 for MeasureHeader, 0 to n for</span>
<span class="sd">        CategoricalHeader)</span>
<span class="sd">    - get_units:</span>
<span class="sd">        gives the list of the unit used for each column (&#39;no unit&#39; is </span>
<span class="sd">        returned for each column with no specified unit)</span>
<span class="sd">    - get_all_units:</span>
<span class="sd">        gives the list of conversion table for each column (&#39;no unit&#39; is</span>
<span class="sd">        returned for each column with no specified unit)</span>
<span class="sd">    - disp:</span>
<span class="sd">        gives the main attributes of a Header</span>
<span class="sd">    - get_value(line_num, column=None):</span>
<span class="sd">        gives the value located at the line line_num and at the column column</span>
<span class="sd">        (defined by it&#39;s label or it&#39;s number) or the fist one. Since we use</span>
<span class="sd">        python, we have decided that to access the first element of the</span>
<span class="sd">        column, line_num must be equal to 0.</span>
<span class="sd">    - get_item_name(line_num):</span>
<span class="sd">        line_num can here be an integer or a list of integer. The function</span>
<span class="sd">        returns the corresponding values of the first column.</span>
<span class="sd">    - copy:</span>
<span class="sd">        creates a copy of the header</span>
<span class="sd">                </span>
<span class="sd">    *(non abstract method)*</span>
<span class="sd">    </span>
<span class="sd">    - check_header_update(flag, ind, new_header):</span>
<span class="sd">        flag: &#39;all&#39;, &#39;dim_chg&#39;, &#39;new&#39;, &#39;remove&#39;, &#39;chg&#39;, &#39;perm&#39;,&#39;chg&amp;new&#39; or</span>
<span class="sd">        &#39;chg&amp;rm&#39;  </span>
<span class="sd">            </span>
<span class="sd">        ind: numpy.array of shape (n,)</span>
<span class="sd">        </span>
<span class="sd">        basics checks when updating data and giving a new header</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Define an abstract constructor which will not be used, but serves for</span>
    <span class="c1"># the the code analyzer to learn the attributes mandatory for a Header</span>
    <span class="c1"># class</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_label</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_column_descriptors</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_elem</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Attributes label and column_descriptors can be seen but not modified</span>
    <span class="c1"># outside of the class (only get methods, no setters).</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;general label of the header&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">column_descriptors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;list of DimensionDescription instances describing each column&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_descriptors</span>

    <span class="c1"># Properties is_measure, is_undifferentiated, is_categorical_with_values</span>
    <span class="c1">#  help to differentiate different types of headers faster in other modules</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_measure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;fast way to differentiate measure headers from categorical ones&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_categorical</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_categorical_with_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;fast way to test if a header is categorical with values</span>
<span class="sd">        (ie list of elements)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_categorical</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_n_columns</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_undifferentiated</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;fast way to test if a header is categorical with no values&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_categorical</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_n_columns</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="c1"># Methods</span>
    <span class="k">def</span> <span class="nf">check_header_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">new_header</span><span class="p">:</span> <span class="s1">&#39;Header&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;basics checks when updating data and giving a new header&quot;&quot;&quot;</span>
        <span class="c1"># check types of parameters</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_header</span><span class="p">,</span> <span class="n">Header</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;new_header must be a header&quot;</span><span class="p">)</span>

        <span class="c1"># &#39;dim_chg&#39; flag allows any change!</span>
        <span class="k">if</span> <span class="n">flag</span> <span class="o">==</span> <span class="s1">&#39;dim_chg&#39;</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># check that the types are coherent</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_categorical</span> <span class="o">!=</span> <span class="n">new_header</span><span class="o">.</span><span class="n">is_categorical</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;both headers must be of same type&quot;</span><span class="p">)</span>

        <span class="c1"># check that labels are preserved</span>
        <span class="k">if</span> <span class="n">new_header</span><span class="o">.</span><span class="n">_label</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;both headers must have the same label&quot;</span><span class="p">)</span>

        <span class="c1"># check that column descriptors are preserved (note that there can</span>
        <span class="c1"># be additional columns though)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">new_header</span><span class="o">.</span><span class="n">_column_descriptors</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_column_descriptors</span><span class="p">)]</span> <span class="o">!=</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_column_descriptors</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;sub-labels are not preserved&quot;</span><span class="p">)</span>

        <span class="c1"># only &#39;all&#39; and &#39;dim_chg&#39; flag allows to change n_elem as we want</span>
        <span class="k">if</span> <span class="n">flag</span> <span class="o">==</span> <span class="s1">&#39;new&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">new_header</span><span class="o">.</span><span class="n">n_elem</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_elem</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;the new headers has the wrong number of &quot;</span>
                                <span class="s2">&quot;elements&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">flag</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;chg&#39;</span> <span class="s1">&#39;perm&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">new_header</span><span class="o">.</span><span class="n">n_elem</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_elem</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;both headers must have the same number &quot;</span>
                                <span class="s2">&quot;of elements&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">flag</span> <span class="o">==</span> <span class="s1">&#39;remove&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">new_header</span><span class="o">.</span><span class="n">n_elem</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_elem</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;the new headers has the wrong number of &quot;</span>
                                <span class="s2">&quot;elements&quot;</span><span class="p">)</span>
        <span class="c1"># &#39;chg&amp;new&#39; and &#39;chg&amp;rm&#39; flags impose ind to be an array of array</span>
        <span class="c1"># with the first element being the array of indices to be changed</span>
        <span class="c1"># and the second element being an array of new indices</span>
        <span class="k">elif</span> <span class="n">flag</span> <span class="o">==</span> <span class="s1">&#39;chg&amp;new&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">new_header</span><span class="o">.</span><span class="n">n_elem</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_elem</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;the new headers has the wrong number of &quot;</span>
                                <span class="s2">&quot;elements&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">flag</span> <span class="o">==</span> <span class="s1">&#39;chg&amp;rm&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">new_header</span><span class="o">.</span><span class="n">n_elem</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_elem</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;the new headers has the wrong number of &quot;</span>
                                <span class="s2">&quot;elements&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown flag&quot;</span><span class="p">)</span>

    <span class="c1"># abstract methods</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">n_elem</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;gives the the number of elements/samples in that dimension&quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">is_categorical</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;used for the properties is_measure, is_categorical_with_values and</span>
<span class="sd">        is_undifferentiated, fast way to differentiate categorical and measure</span>
<span class="sd">        headers&quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Override the default Equals behavior&quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_n_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns the number of columns&quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;gives a list of the units of all the columns&quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_all_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;gives a list of the conversion tables for the units of all the</span>
<span class="sd">        columns&quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">disp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;display some information about the header&quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;get the value of the line of number line of the column column</span>
<span class="sd">        (defined by it&#39;s label or number) or the first column&quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_item_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line_num</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;get the value(s) of the line(s) in line_num (it can be an int or a list</span>
<span class="sd">        of int), of the first column&quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;creates a copy of the Header instance&quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="CategoricalHeader"><a class="viewcode-back" href="../xdata.html#xdata.CategoricalHeader">[docs]</a><span class="k">class</span> <span class="nc">CategoricalHeader</span><span class="p">(</span><span class="n">Header</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This class allows the creation of a header for a categorical dimension</span>
<span class="sd">    of a dataset.</span>
<span class="sd">    </span>
<span class="sd">    CategoricalHeader is used for categorical dimensions of a dataset. This</span>
<span class="sd">    means that this dimension is either not continuous or that the data has not</span>
<span class="sd">    been collected regularly in this dimension. Therefore, their is no scale,</span>
<span class="sd">    measure for this dimension. It is more a collection of objects.</span>
<span class="sd">    </span>
<span class="sd">    A CategoricalHeader has a general label as well as one or several</span>
<span class="sd">    DimensionDescription objects stored in column_descriptors to describe each</span>
<span class="sd">    of the features. For each feature, values can be given (e.g. for &#39;fruits&#39;</span>
<span class="sd">    values would be &#39;apple&#39;, &#39;pear&#39;, &#39;blueberry&#39;, &#39;watermelon&#39;...) or be a list</span>
<span class="sd">    of numbers. The first case corresponds to &#39;is_categorical_with_values&#39;, the</span>
<span class="sd">    second to &#39;is_undifferentiated&#39;</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    **Parameters**</span>

<span class="sd">    - label:</span>
<span class="sd">        name of the header</span>
<span class="sd">        (type: str)</span>
<span class="sd">    - column_descriptors:</span>
<span class="sd">        description of the dimension of each feature</span>
<span class="sd">        </span>
<span class="sd">        (type str, DimensionDescription or a list of such elements)</span>
<span class="sd">        </span>
<span class="sd">        (optional, the case with no column is possible. The legend would then</span>
<span class="sd">        be a list of int [1, 2, ...], it is undifferentiated)</span>
<span class="sd">     </span>
<span class="sd">    - n_elem:</span>
<span class="sd">        number of element in the column(s)</span>
<span class="sd">        </span>
<span class="sd">        (type int)</span>
<span class="sd">        </span>
<span class="sd">        (optional if values is specified)</span>
<span class="sd">            </span>
<span class="sd">    - values:</span>
<span class="sd">        content of the various subdimensions</span>
<span class="sd">        </span>
<span class="sd">        (type DataFrame from pandas (pandas.core.frame.DataFrame) of shape</span>
<span class="sd">        (n_elem, len(column_descriptors))</span>
<span class="sd">        </span>
<span class="sd">        (optional if it is just undifferentiated series of measures and that</span>
<span class="sd">        n_elem is given)</span>
<span class="sd">            </span>
<span class="sd">    </span>
<span class="sd">    **Attributes**</span>

<span class="sd">    - label:</span>
<span class="sd">        name of the dimension</span>
<span class="sd">        (type str)</span>
<span class="sd">    - column_descriptors:</span>
<span class="sd">        list of the DimensionDescription of each of the columns of values</span>
<span class="sd">    - values:</span>
<span class="sd">        content of the various subdimensions (pandas DataFrame</span>
<span class="sd">        (pandas.core.frame.DataFrame)of shape (n_elem, len(column_descriptors))</span>
<span class="sd">      </span>
<span class="sd">    **Methods**</span>

<span class="sd">    *(methods imposed by inheritance)*</span>
<span class="sd">    </span>
<span class="sd">    - n_elem:</span>
<span class="sd">        number of element in the column(s)/ number of samples number of lines</span>
<span class="sd">        of values</span>
<span class="sd">    - is_categorical:</span>
<span class="sd">        differentiate measure and categorical headers for the properties</span>
<span class="sd">        is_measure, is_categorical_with_values and is_undifferentiated</span>
<span class="sd">    - is_categorical:</span>
<span class="sd">        returns True since it is the class CategoricalHeader</span>
<span class="sd">    - __eq__:</span>
<span class="sd">        compares all the fields of the headers (returns True if all the</span>
<span class="sd">        fields are the same) it can be used by writing header1 == header2</span>
<span class="sd">    - get_n_columns:</span>
<span class="sd">        gives the number of columns (1 for MeasureHeader, 0 to n for</span>
<span class="sd">        CategoricalHeader)</span>
<span class="sd">    - get_units:</span>
<span class="sd">        gives the list of the unit used for each column (&#39;no unit&#39; is returned</span>
<span class="sd">        for each column with no specified unit)</span>
<span class="sd">    - get_all_units:</span>
<span class="sd">        gives the list of conversion table for each column (&#39;no unit&#39; is</span>
<span class="sd">        returned for each column with no specified unit)</span>
<span class="sd">    - disp:</span>
<span class="sd">        gives the main attributes of a Header</span>
<span class="sd">    - get_value(line_num, column=None):</span>
<span class="sd">        gives the value located at the line line_num and at the column column</span>
<span class="sd">        (defined by it&#39;s label or it&#39;s number) or the fist one. Since we use</span>
<span class="sd">        python, we have decided that to access the first element of the</span>
<span class="sd">        column, line_num must be equal to 0.</span>
<span class="sd">    - get_item_name(line_num):</span>
<span class="sd">        line_num can here be an integer or a list of integer. The function</span>
<span class="sd">        returns the corresponding values of the first column</span>
<span class="sd">    - copy:</span>
<span class="sd">        creates a copy of the categorical header</span>
<span class="sd">    </span>
<span class="sd">    *(other methods)*</span>
<span class="sd">    </span>
<span class="sd">    - add_column(column_descriptor, values):</span>
<span class="sd">        column_descriptor must be of type str or DimensionDescription</span>
<span class="sd">        values must be of type pandas.core.series.Series this method allows</span>
<span class="sd">        to created a new categorical header from the attributes of a previous</span>
<span class="sd">        categorical header, while adding a new column (it can be useful for</span>
<span class="sd">        selections or to add colors)</span>
<span class="sd">    - update_categorical_header(flag, ind, values):</span>
<span class="sd">        flags can be: &#39;all&#39;, &#39;new&#39;, &#39;chg&#39;, &#39;chg&amp;new&#39;, &#39;chg&amp;rm&#39;, &#39;remove&#39;,</span>
<span class="sd">        &#39;perm&#39;</span>

<span class="sd">        idn indicates were the changes take place</span>

<span class="sd">        values contains the new values</span>

<span class="sd">        This method allows filters to create a new categorical header from</span>
<span class="sd">        the current one, with some changes in the values</span>
<span class="sd">    - merge_lines(ind):</span>
<span class="sd">        When merging some data, the corresponding header&#39;s lines must be</span>
<span class="sd">        merged as well. merge_lines returns for each column all the</span>
<span class="sd">        encountered values with no repetitions in the from of a pandas Series.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># noinspection PyMissingConstructor</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">label</span><span class="p">,</span>
                 <span class="n">column_descriptors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">n_elem</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">values</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructor of the class CategoricalHeader&quot;&quot;&quot;</span>
        <span class="c1"># label is not optional and must be of type string</span>
        <span class="c1"># label can be different from the labels of the columns</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;The header&#39;s label must be of type str&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_label</span> <span class="o">=</span> <span class="n">label</span>
        <span class="c1"># if values is None, so is column_descriptors, but we must have n_elem</span>
        <span class="k">if</span> <span class="n">values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n_elem</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;if no value is given, n_elem must be given&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_elem</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;n_elem must be of type int&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">column_descriptors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">column_descriptors</span> <span class="o">==</span> <span class="p">[])):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;if there is no values, there are no columns&quot;</span>
                                <span class="s2">&quot; to be described&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_elem</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_column_descriptors</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;values must be a pandas DataFrame&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># values is a DataFrame</span>
            <span class="c1"># we have to check that it has the correct shape</span>
            <span class="c1"># however, labels of the data_frame will not be taken into</span>
            <span class="c1"># consideration correspond</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_elem</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">n_elem</span> <span class="o">==</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;n_elem is not coherent with shape of &quot;</span>
                                    <span class="s2">&quot;values&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">n_elem</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;n_elem must but of type int&quot;</span><span class="p">)</span>
            <span class="c1"># n_elem is either not given or correspond to the number of</span>
            <span class="c1"># lines of the data_frame</span>
            <span class="c1"># let&#39;s check that values and column_descriptors are size coherent</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">column_descriptors</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column_descriptors</span><span class="p">,</span> <span class="n">DimensionDescription</span><span class="p">)):</span>
                <span class="n">column_descriptors</span> <span class="o">=</span> <span class="p">[</span><span class="n">column_descriptors</span><span class="p">]</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column_descriptors</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;column_descriptors must be of type str, &quot;</span>
                                <span class="s2">&quot;DimensionDescription or a list of such &quot;</span>
                                <span class="s2">&quot;elements&quot;</span><span class="p">)</span>
            <span class="c1"># column_descriptors is now a list</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">column_descriptors</span><span class="p">)</span> <span class="o">!=</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;column_descriptors and values must have the &quot;</span>
                                <span class="s2">&quot;same length&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_values</span> <span class="o">=</span> <span class="n">values</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_column_descriptors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">column_descriptors</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column_descriptors</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">dim_description</span> <span class="o">=</span> <span class="n">create_dimension_description</span><span class="p">(</span>
                        <span class="n">column_descriptors</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_column_descriptors</span> <span class="o">+=</span> <span class="p">[</span><span class="n">dim_description</span><span class="p">]</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column_descriptors</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">DimensionDescription</span><span class="p">):</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">column_descriptors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dimension_type</span>
                    <span class="k">if</span> <span class="n">d</span> <span class="o">!=</span> <span class="s1">&#39;mixed&#39;</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                            <span class="c1"># /!\data_frame[column][line]</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">DimensionDescription</span><span class="o">.</span><span class="n">infertype</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">e</span><span class="p">])</span>
                                    <span class="o">!=</span> <span class="n">d</span><span class="p">):</span>
                                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;dimension_types of &quot;</span>
                                                <span class="s2">&quot;column_descriptors must be &quot;</span>
                                                <span class="s2">&quot;coherent with the data in &quot;</span>
                                                <span class="s2">&quot;values&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_column_descriptors</span> <span class="o">+=</span> <span class="p">[</span><span class="n">column_descriptors</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;all column_descriptors elements must be &quot;</span>
                                    <span class="s2">&quot;either of type str or &quot;</span>
                                    <span class="s2">&quot;DimensionDescription&quot;</span><span class="p">)</span>

    <span class="c1"># private property but with get access</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_elem</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;number of elements/samples in that dimension, line number of values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_categorical</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;CategoricalHeader instances are all categorical&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;values is a pandas DataFrame&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span>

    <span class="c1"># methods</span>
    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;CategoricalHeader&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Override the default Equals behavior&quot;&quot;&quot;</span>
        <span class="c1"># the two headers must have the same type</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">CategoricalHeader</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># the label must be the same</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">_label</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># the column_descriptors must be the same</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_categorical_with_values</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">is_categorical_with_values</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_categorical_with_values</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_column_descriptors</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_column_descriptors</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_column_descriptors</span><span class="p">)):</span>
                <span class="n">self_descriptor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_descriptors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">other_descriptor</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_column_descriptors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">self_descriptor</span><span class="o">.</span><span class="n">label</span> <span class="o">!=</span> <span class="n">other_descriptor</span><span class="o">.</span><span class="n">label</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">self_descriptor</span><span class="o">.</span><span class="n">dimension_type</span> <span class="o">!=</span>
                        <span class="n">other_descriptor</span><span class="o">.</span><span class="n">dimension_type</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">self_descriptor</span><span class="o">.</span><span class="n">unit</span> <span class="o">!=</span> <span class="n">other_descriptor</span><span class="o">.</span><span class="n">unit</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">self_descriptor</span><span class="o">.</span><span class="n">all_units</span> <span class="o">!=</span> <span class="n">other_descriptor</span><span class="o">.</span><span class="n">all_units</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># the content of values must be the same</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">column</span><span class="p">][</span><span class="n">line</span><span class="p">]</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">column</span><span class="p">][</span><span class="n">line</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">get_n_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns the number of columns&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_descriptors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_column_descriptors</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;gives a list of the units of all the columns&quot;&quot;&quot;</span>
        <span class="n">units</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_n_columns</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">dimension_description</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_descriptors</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dimension_description</span><span class="o">.</span><span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">units</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;no unit&#39;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">units</span> <span class="o">+=</span> <span class="p">[</span><span class="n">dimension_description</span><span class="o">.</span><span class="n">unit</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">units</span>

    <span class="k">def</span> <span class="nf">get_all_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;gives a list of the conversion tables for the units of all the</span>
<span class="sd">        columns&quot;&quot;&quot;</span>
        <span class="n">all_units</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_n_columns</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dimension_description</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_descriptors</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dimension_description</span><span class="o">.</span><span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">all_units</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;no unit&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">all_units</span> <span class="o">+=</span> <span class="p">[</span><span class="n">dimension_description</span><span class="o">.</span><span class="n">all_units</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">all_units</span>

    <span class="k">def</span> <span class="nf">disp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;display some information about the header&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;CategoricalHeader: &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;columns:&quot;</span><span class="p">)</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_descriptors</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_n_columns</span><span class="p">()):</span>
            <span class="n">label</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">columns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">columns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">unit</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unit</span> <span class="o">=</span> <span class="s1">&#39; (&#39;</span> <span class="o">+</span> <span class="n">columns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">label</span> <span class="o">+</span> <span class="n">unit</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;n_elem:&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_elem</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;get the value of the line of number line of the column defined by</span>
<span class="sd">        column&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;line must be of type int&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">line</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_elem</span> <span class="o">|</span> <span class="n">line</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;line must be in [0, n_elem[&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">column</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">column</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_n_columns</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># line_num must be 0 to have the first elem of a list in</span>
                <span class="c1"># python.</span>
                <span class="k">return</span> <span class="n">line</span>
            <span class="k">if</span> <span class="n">column</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_n_columns</span><span class="p">()</span> <span class="o">|</span> <span class="n">column</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;column is a str or an int in [0, n_col[&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">column</span><span class="p">][</span><span class="n">line</span><span class="p">]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;column is either the label of a column or it&#39;s&quot;</span>
                            <span class="s2">&quot;number (int)&quot;</span><span class="p">)</span>
        <span class="c1"># if it is a string</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">dim_descriptor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_descriptors</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dim_descriptor</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="n">column</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">count</span><span class="p">][</span><span class="n">line</span><span class="p">]</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;column is either the label of a column or it&#39;s&quot;</span>
                        <span class="s2">&quot;number (int)&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_item_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;get the value(s) of the line(s) in line_num (it can be an int or a list</span>
<span class="sd">        of int), of the first column&quot;&quot;&quot;</span>
        <span class="c1"># this function is the same for both the headers, but it could be</span>
        <span class="c1"># modified to choose witch column we want for categorical headers</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">line</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_elem</span> <span class="ow">or</span> <span class="n">line</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;line_num must be in [0, n_elem[&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">item_names</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;all line numbers must be integers&quot;</span><span class="p">)</span>
                <span class="n">item_names</span> <span class="o">+=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
            <span class="k">return</span> <span class="n">item_names</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;line_num must be an int or a list of int&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_descriptor</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;this method allows to add a column to a categorical header&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">series</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;values must be of type pd.core.series.Series&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;values must have the correct amount of lines&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column_descriptor</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">column_descriptor</span> <span class="o">=</span> <span class="n">create_dimension_description</span><span class="p">(</span><span class="n">column_descriptor</span><span class="p">,</span>
                                                             <span class="n">values</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column_descriptor</span><span class="p">,</span> <span class="n">DimensionDescription</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;column_descriptor must be of type str or &quot;</span>
                            <span class="s2">&quot;DimensionDescription&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># if it was a given DimensionDescriptor, let&#39;s check that the</span>
            <span class="c1"># dimension_type correspond to that of the values</span>
            <span class="n">dimension_type</span> <span class="o">=</span> <span class="n">column_descriptor</span><span class="o">.</span><span class="n">dimension_type</span>
            <span class="k">if</span> <span class="n">dimension_type</span> <span class="o">!=</span> <span class="s1">&#39;mixed&#39;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">DimensionDescription</span><span class="o">.</span><span class="n">infertype</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dimension_type</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;the dimension_type of the &quot;</span>
                                        <span class="s2">&quot;DimensionDescription must correspond&quot;</span>
                                        <span class="s2">&quot; to that of the values&quot;</span><span class="p">)</span>
        <span class="n">column_descriptors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_descriptors</span> <span class="o">+</span> <span class="p">[</span><span class="n">column_descriptor</span><span class="p">]</span>
        <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_values</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">column_descriptors</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>
        <span class="k">return</span><span class="p">(</span><span class="n">CategoricalHeader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">,</span>
                                 <span class="n">column_descriptors</span><span class="p">,</span>
                                 <span class="n">values</span><span class="o">=</span><span class="n">new_values</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">update_categorical_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;updates the values of a categorical header&quot;&quot;&quot;</span>
        <span class="c1"># flag &#39;all&#39;: all the values can change, they are all given</span>
        <span class="c1"># in values argument of type pandas DataFrame</span>
        <span class="k">if</span> <span class="n">flag</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ind</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">ind</span> <span class="o">==</span> <span class="p">[])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">ind</span> <span class="o">==</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_elem</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;values must be a pandas DataFrame&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;values must keep the same number of &quot;</span>
                                    <span class="s2">&quot;columns&quot;</span><span class="p">)</span>
                <span class="n">column_descriptors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_descriptors</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">column_descriptors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">dimension_type</span> <span class="o">!=</span> <span class="s1">&#39;mixed&#39;</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                            <span class="c1"># noinspection PyPep8</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">column_descriptors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">dimension_type</span> <span class="o">!=</span>
                                    <span class="n">DimensionDescription</span><span class="o">.</span><span class="n">infertype</span><span class="p">(</span>
                                    <span class="n">values</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">])):</span>
                                <span class="n">column_descriptors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">set_dimtype_to_mixed</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">CategoricalHeader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">,</span>
                                         <span class="n">column_descriptors</span><span class="p">,</span>
                                         <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ind must be empty or the list of all the &quot;</span>
                                <span class="s2">&quot;indices that have changed&quot;</span><span class="p">)</span>
        <span class="c1"># flag &#39;new&#39;: adding new lines, some of which can be the merging of</span>
        <span class="c1"># many lines</span>
        <span class="k">elif</span> <span class="n">flag</span> <span class="o">==</span> <span class="s1">&#39;new&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ind</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;values must be a list of pandas Series&quot;</span><span class="p">)</span>
                <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">new_descriptors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_descriptors</span>
                <span class="k">if</span> <span class="n">new_descriptors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">new_descriptors</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_n_columns</span><span class="p">()</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">series</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;values must be a list of pandas &quot;</span>
                                        <span class="s2">&quot;Series&quot;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;all series in values must have the&quot;</span>
                                        <span class="s2">&quot; same number of elements that the &quot;</span>
                                        <span class="s2">&quot;number of column of the header&quot;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
                        <span class="n">dimtype</span> <span class="o">=</span> <span class="n">new_descriptors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dimension_type</span>
                        <span class="c1"># noinspection PyPep8</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">dimtype</span> <span class="o">!=</span> <span class="s1">&#39;mixed&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                                    <span class="n">dimtype</span> <span class="o">!=</span> <span class="n">DimensionDescription</span><span class="o">.</span><span class="n">infertype</span><span class="p">(</span>
                                    <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                            <span class="n">new_descriptors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_dimtype_to_mixed</span><span class="p">()</span>
                    <span class="n">new_values</span> <span class="o">=</span> <span class="n">new_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">CategoricalHeader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">,</span>
                                         <span class="n">new_descriptors</span><span class="p">,</span>
                                         <span class="n">values</span><span class="o">=</span><span class="n">new_values</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ind must be empty or the list of all the &quot;</span>
                                <span class="s2">&quot;indices that have changed&quot;</span><span class="p">)</span>
        <span class="c1"># flag &#39;chg&#39;: changing some lines (keep the same number of lines)</span>
        <span class="k">elif</span> <span class="n">flag</span> <span class="o">==</span> <span class="s1">&#39;chg&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ind must be the list of the indices of the&quot;</span>
                                <span class="s2">&quot; lines that have changed&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;values must be a list of the new lines &quot;</span>
                                <span class="s2">&quot;(pandas series)&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;values and ind must have the same length&quot;</span><span class="p">)</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">new_descriptors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_descriptors</span>
            <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_n_columns</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ind must be the list of the indices of&quot;</span>
                                    <span class="s2">&quot;the lines that have changed&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_elem</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;for a chg flag, indices must be in range&quot;</span>
                                    <span class="s2">&quot; of n_elem&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">series</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;new lines must be pandas series&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;all series must have the same number of &quot;</span>
                                    <span class="s2">&quot;element as the number of column of the &quot;</span>
                                    <span class="s2">&quot;header&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
                    <span class="n">dimtype</span> <span class="o">=</span> <span class="n">new_descriptors</span><span class="p">[</span><span class="n">cc</span><span class="p">]</span><span class="o">.</span><span class="n">dimension_type</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">dimtype</span> <span class="o">!=</span> <span class="s1">&#39;mixed&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                        <span class="n">dimtype</span> <span class="o">!=</span> <span class="n">DimensionDescription</span><span class="o">.</span><span class="n">infertype</span><span class="p">(</span>
                                <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">cc</span><span class="p">])):</span>
                        <span class="n">new_descriptors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_dimtype_to_mixed</span><span class="p">()</span>
                <span class="n">new_values</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">CategoricalHeader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">,</span>
                                     <span class="n">new_descriptors</span><span class="p">,</span>
                                     <span class="n">values</span><span class="o">=</span><span class="n">new_values</span><span class="p">)</span>
        <span class="c1"># flag &#39;remove&#39;: suppress some lines</span>
        <span class="k">elif</span> <span class="n">flag</span> <span class="o">==</span> <span class="s1">&#39;remove&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ind must be the list of the indices of the&quot;</span>
                                <span class="s2">&quot; lines that have changed&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;all indices must be of type int&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_elem</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;indices must correspond to an existing&quot;</span>
                                    <span class="s2">&quot; line&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">values</span> <span class="o">!=</span> <span class="p">[]):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;no new values can be given when only &quot;</span>
                                <span class="s2">&quot;removing lines&quot;</span><span class="p">)</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="n">new_values</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">new_values</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="n">new_values</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">CategoricalHeader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_column_descriptors</span><span class="p">,</span>
                                     <span class="n">values</span><span class="o">=</span><span class="n">new_values</span><span class="p">)</span>
        <span class="c1"># flag &#39;perm&#39;: change the lines order</span>
        <span class="k">elif</span> <span class="n">flag</span> <span class="o">==</span> <span class="s1">&#39;perm&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">values</span> <span class="o">!=</span> <span class="p">[]):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;no new values can be given when only &quot;</span>
                                <span class="s2">&quot;permuting lines&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ind must be the list of the indices of the&quot;</span>
                                <span class="s2">&quot; lines that have changed&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_elem</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ind must be the list of all the indices in &quot;</span>
                                <span class="s2">&quot;the new order&quot;</span><span class="p">)</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;all indices must be integers&quot;</span><span class="p">)</span>
                <span class="n">new_values</span> <span class="o">=</span> <span class="n">new_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                <span class="n">new_values</span> <span class="o">=</span> <span class="n">new_values</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">CategoricalHeader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_column_descriptors</span><span class="p">,</span>
                                     <span class="n">values</span><span class="o">=</span><span class="n">new_values</span><span class="p">)</span>
        <span class="c1"># flag &#39;chg&amp;new&#39;: combination of &#39;chg&#39; and &#39;new&#39;</span>
        <span class="k">elif</span> <span class="n">flag</span> <span class="o">==</span> <span class="s1">&#39;chg&amp;new&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ind must be a list of the list of the &quot;</span>
                                <span class="s2">&quot;indices that have changed and the list of &quot;</span>
                                <span class="s2">&quot;those to remove&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;values is of type list&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;values must contains the values to change &quot;</span>
                                <span class="s2">&quot;and the values to add&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span>
                      <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">list</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;values must contains the values to change &quot;</span>
                                <span class="s2">&quot;and the values to add in two lists&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">ind_chg</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ind_chg</span> <span class="o">=</span> <span class="n">ind</span>
            <span class="c1"># let&#39;s first change the lines that needs to be changed...</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind_chg</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;all the lines to be changed must be given &quot;</span>
                                <span class="s2">&quot;a value&quot;</span><span class="p">)</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">new_descriptors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_descriptors</span>
            <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_n_columns</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind_chg</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind_chg</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;all indices must be of type int&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">ind_chg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">ind_chg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_elem</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;for a chg action, indices must be in &quot;</span>
                                    <span class="s2">&quot;range of n_elem&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">series</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;new lines must be pandas series&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;all series must have the same number of &quot;</span>
                                    <span class="s2">&quot;element as the number of column of the &quot;</span>
                                    <span class="s2">&quot;header&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
                    <span class="n">dimtype</span> <span class="o">=</span> <span class="n">new_descriptors</span><span class="p">[</span><span class="n">cc</span><span class="p">]</span><span class="o">.</span><span class="n">dimension_type</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">dimtype</span> <span class="o">!=</span> <span class="s1">&#39;mixed&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                        <span class="n">dimtype</span> <span class="o">!=</span> <span class="n">DimensionDescription</span><span class="o">.</span><span class="n">infertype</span><span class="p">(</span>
                                <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">cc</span><span class="p">])):</span>
                        <span class="n">new_descriptors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_dimtype_to_mixed</span><span class="p">()</span>
                <span class="n">new_values</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">ind_chg</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="c1"># ...now let&#39;s add the new lines</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">series</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;values must be a list of pandas Series&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;all series in values must have the same &quot;</span>
                                    <span class="s2">&quot;number of elements that the number of &quot;</span>
                                    <span class="s2">&quot;column of the header&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
                    <span class="n">dimtype</span> <span class="o">=</span> <span class="n">new_descriptors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dimension_type</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">dimtype</span> <span class="o">!=</span> <span class="s1">&#39;mixed&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                            <span class="n">dimtype</span> <span class="o">!=</span> <span class="n">DimensionDescription</span><span class="o">.</span><span class="n">infertype</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                        <span class="n">new_descriptors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_dimtype_to_mixed</span><span class="p">()</span>
                <span class="n">new_values</span> <span class="o">=</span> <span class="n">new_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">CategoricalHeader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">,</span>
                                     <span class="n">new_descriptors</span><span class="p">,</span>
                                     <span class="n">values</span><span class="o">=</span><span class="n">new_values</span><span class="p">)</span>
        <span class="c1"># flag &#39;chg&amp;rm&#39;: combination of &#39;chg&#39; and &#39;rm&#39;</span>
        <span class="k">elif</span> <span class="n">flag</span> <span class="o">==</span> <span class="s1">&#39;chg&amp;rm&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ind must be a list of the list of the &quot;</span>
                                <span class="s2">&quot;indices that have changed and the list of &quot;</span>
                                <span class="s2">&quot;those to remove&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;values is of type list&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ind must contains the lines to change &quot;</span>
                                <span class="s2">&quot;and the lines to remove&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> 
                      <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">list</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;values must contains the values to change &quot;</span>
                                <span class="s2">&quot;and the values to add in two lists&quot;</span><span class="p">)</span>
            <span class="c1"># let&#39;s first change the lines that needs to be changed...</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;all the lines to be changed must be given &quot;</span>
                                <span class="s2">&quot;a value&quot;</span><span class="p">)</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">new_descriptors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_descriptors</span>
            <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_n_columns</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;all indices must be of type int&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_elem</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;for a chg action, indices must be in &quot;</span>
                                    <span class="s2">&quot;range of n_elem&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">series</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;new lines must be pandas series&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;all series must have the same number of &quot;</span>
                                    <span class="s2">&quot;element as the number of column of the &quot;</span>
                                    <span class="s2">&quot;header&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
                    <span class="n">dimtype</span> <span class="o">=</span> <span class="n">new_descriptors</span><span class="p">[</span><span class="n">cc</span><span class="p">]</span><span class="o">.</span><span class="n">dimension_type</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">dimtype</span> <span class="o">!=</span> <span class="s1">&#39;mixed&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                            <span class="n">dimtype</span> <span class="o">!=</span> <span class="n">DimensionDescription</span><span class="o">.</span><span class="n">infertype</span><span class="p">(</span>
                            <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">cc</span><span class="p">])):</span>
                        <span class="n">new_descriptors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_dimtype_to_mixed</span><span class="p">()</span>
                <span class="n">new_values</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1"># ...now let&#39;s remove the unwanted lines</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;all indices must be of type int&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_elem</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;indices must correspond to an existing&quot;</span>
                                    <span class="s2">&quot; line&quot;</span><span class="p">)</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="n">new_values</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">new_values</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="n">new_values</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">CategoricalHeader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">,</span>
                                     <span class="n">new_descriptors</span><span class="p">,</span>
                                     <span class="n">values</span><span class="o">=</span><span class="n">new_values</span><span class="p">)</span>
        <span class="c1"># all the accepted flags were listed before, so the argument is not</span>
        <span class="c1"># valid</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;the given flag must be &#39;all&#39;, &#39;perm&#39;, &#39;chg&#39;, &#39;new&#39;&quot;</span>
                        <span class="s2">&quot; &#39;remove&#39;, &#39;chg&amp;new&#39;, or &#39;chg&amp;rm&#39;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">merge_lines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;creating the values (pandas Series) for merged lines&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ind must be a list of indices&quot;</span><span class="p">)</span>
        <span class="n">n_col</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_column_descriptors</span><span class="p">)</span>
        <span class="n">merge</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_col</span><span class="p">):</span>
            <span class="n">merge</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;all indices must be of type int&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_elem</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;indices must correspond to an element of &quot;</span>
                                <span class="s2">&quot;values&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_col</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">merge</span><span class="p">[</span><span class="n">j</span><span class="p">]):</span>
                    <span class="n">merge</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_col</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_descriptors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">dimension_type</span> <span class="o">==</span> <span class="s1">&#39;color&#39;</span><span class="p">:</span>
                <span class="n">red</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">green</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">blue</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">merge</span><span class="p">[</span><span class="n">j</span><span class="p">]):</span>
                    <span class="n">red</span> <span class="o">+=</span> <span class="n">i</span><span class="o">.</span><span class="n">rgb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">green</span> <span class="o">+=</span> <span class="n">i</span><span class="o">.</span><span class="n">rgb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">blue</span> <span class="o">+=</span> <span class="n">i</span><span class="o">.</span><span class="n">rgb</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">merge</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">merge</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">Color</span><span class="p">((</span><span class="n">red</span><span class="o">/</span><span class="n">n</span><span class="p">,</span> <span class="n">green</span><span class="o">/</span><span class="n">n</span><span class="p">,</span> <span class="n">blue</span><span class="o">/</span><span class="n">n</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">merge</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;creates a copy of a categoricalHeader&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_descriptors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">column_descriptors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">column_descriptors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_descriptors</span><span class="p">:</span>
                <span class="n">column_descriptors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cc</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">CategoricalHeader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
                                 <span class="n">column_descriptors</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">n_elem</span><span class="p">,</span>
                                 <span class="n">values</span><span class="p">)</span></div>


<div class="viewcode-block" id="MeasureHeader"><a class="viewcode-back" href="../xdata.html#xdata.MeasureHeader">[docs]</a><span class="k">class</span> <span class="nc">MeasureHeader</span><span class="p">(</span><span class="n">Header</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This class allows the creation of a header for a measurable dimensions</span>
<span class="sd">    of a dataset.</span>

<span class="sd">    MeasureHeader is used for a measurable dimensions of a dataset. This</span>
<span class="sd">    means that this dimension is continuous and that the data has been</span>
<span class="sd">    collected regularly in this dimension. Therefore, a scale, a start</span>
<span class="sd">    attributes can be defined.</span>

<span class="sd">    A MeasureHeader has a general label and only one column (there is only one</span>
<span class="sd">    feature of interest). This column is described by a single</span>
<span class="sd">    DimensionDescription object, but it is still stored in a list</span>
<span class="sd">    (column_descriptors) in order to keep the similarity between the different</span>
<span class="sd">    types of headers. The values are not stored because they can be calculated</span>
<span class="sd">    easily from the start and scale attributes and the n_elem property.</span>


<span class="sd">    **Parameters**</span>

<span class="sd">    - label:</span>
<span class="sd">        name of the header</span>
<span class="sd">        (type str)</span>
<span class="sd">    - start:</span>
<span class="sd">        first value of this dimension</span>
<span class="sd">        (type float or int)</span>
<span class="sd">    - n_elem:</span>
<span class="sd">        number of element in the column</span>
<span class="sd">        (type int)</span>
<span class="sd">    - scale:</span>
<span class="sd">        interval between the values of this dimension</span>
<span class="sd">        (type float or int)</span>
<span class="sd">    - unit:</span>
<span class="sd">        One can define only the unit (e.g. mm) or the conversions as well in</span>
<span class="sd">        the form of a list (e.g. [&#39;mm&#39;, 10**(-3), &#39;m&#39;, 1])</span>

<span class="sd">        (type str or list)</span>

<span class="sd">        (optional)</span>
<span class="sd">    - check_bank:</span>
<span class="sd">        Default value of check_bank is False. If is it True, a unit must be</span>
<span class="sd">        specified, in order to check in the bank of conversion tables if one</span>
<span class="sd">        exists for the given unit.</span>

<span class="sd">        (optional)</span>

<span class="sd">    - column_descriptors:</span>
<span class="sd">        description of the dimension (it&#39;s label must be the same as the</span>
<span class="sd">        general label of the header)</span>

<span class="sd">        (type DimensionDescription)</span>

<span class="sd">        (optional)</span>


<span class="sd">    **Attributes**</span>

<span class="sd">    - label:</span>
<span class="sd">        name of the dimension (type str)</span>
<span class="sd">    - column_descriptors:</span>
<span class="sd">        list of one DimensionDescription instance</span>
<span class="sd">    - unit:</span>
<span class="sd">        main unit for this dimension (i.e. for which conversion value is one)</span>
<span class="sd">    - start:</span>
<span class="sd">        first value of this dimension (type float)</span>
<span class="sd">    - scale:</span>
<span class="sd">        interval between the values of this dimension (type float)</span>

<span class="sd">    **Methods**</span>

<span class="sd">    *(methods imposed by inheritance)*</span>

<span class="sd">    - n_elem:</span>
<span class="sd">        number of element in the column(s)/ number of samples</span>
<span class="sd">    - is_categorical:</span>
<span class="sd">        differentiate measure and categorical headers for the properties</span>
<span class="sd">        is_measure, is_categorical_with_values and is_undifferentiated</span>
<span class="sd">    - __eq__:</span>
<span class="sd">        compares all the fields of the headers (returns True if all the</span>
<span class="sd">        fields are the same) it can be used by writing header1 == header2</span>
<span class="sd">    - get_n_columns:</span>
<span class="sd">        gives the number of columns (1 for MeasureHeader, 0 to n for</span>
<span class="sd">        CategoricalHeader)</span>
<span class="sd">    - get_units:</span>
<span class="sd">        gives the list of the unit used for each column (&#39;no unit&#39; is</span>
<span class="sd">        returned for each column with no specified unit)</span>
<span class="sd">    - get_all_units:</span>
<span class="sd">        gives the list of conversion table for each column (&#39;no unit&#39; is</span>
<span class="sd">        returned for each column with no specified unit)</span>
<span class="sd">    - disp:</span>
<span class="sd">        gives the main attributes of a Header</span>
<span class="sd">    - get_value(line_num, column = None):</span>
<span class="sd">        gives the value located at the line line_num and at the column column</span>
<span class="sd">        (defined by it&#39;s label or it&#39;s number) or the fist one.Since we use</span>
<span class="sd">        python, we have decided that to access the first element of the</span>
<span class="sd">        column, line_num must be equal to 0.</span>
<span class="sd">    - get_item_name(line_num):</span>
<span class="sd">        line_num can here be an integer or a list of integer. The function</span>
<span class="sd">        returns the corresponding values of the first column.</span>

<span class="sd">    *(other methods)*</span>

<span class="sd">    - update_measure_header(start = None, n_elem = None,scale = None):</span>
<span class="sd">        creates a new measure header from the attributes of a previous one,</span>
<span class="sd">        and the specified changes</span>
<span class="sd">    - copy:</span>
<span class="sd">        creates a copy of a MeasureHeader instance</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># noinspection PyMissingConstructor</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">label</span><span class="p">,</span>
                 <span class="n">start</span><span class="p">,</span>
                 <span class="n">n_elem</span><span class="p">,</span>
                 <span class="n">scale</span><span class="p">,</span>
                 <span class="n">unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">check_bank</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">column_descriptors</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Constructor of the class MeasureHeader&quot;&quot;&quot;</span>
        <span class="c1"># label must be of type str</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;label must be of type str&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_label</span> <span class="o">=</span> <span class="n">label</span>
        <span class="c1"># start must be of type int or float</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;start must be of type float or int&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="c1"># n_elem must be of type int</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_elem</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;n_elem must be of type int&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_elem</span> <span class="o">=</span> <span class="n">n_elem</span>
        <span class="c1"># scale must be of type int or float</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;scale must be of type float or int&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
        <span class="c1"># case with a column_descriptors parameter</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column_descriptors</span><span class="p">,</span> <span class="n">DimensionDescription</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">column_descriptors</span><span class="o">.</span><span class="n">label</span> <span class="o">!=</span> <span class="n">label</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s2">&quot;the general label and the label from the &quot;</span>
                    <span class="s2">&quot;column_descriptors must be the same&quot;</span> 
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s2">&quot;you can either choose to use unit (and possibly&quot;</span>
                    <span class="s2">&quot; check_bank) or to use column_descriptors, not both&quot;</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_column_descriptors</span> <span class="o">=</span> <span class="p">[</span><span class="n">column_descriptors</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">column_descriptors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;column_descriptors must be of type&quot;</span>
                            <span class="s2">&quot; DimensionDescription&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">check_bank</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;check_bank must be a boolean&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">check_bank</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Specify a unit so as to checkout the bank&quot;</span><span class="p">)</span>
            <span class="n">dim_description</span> <span class="o">=</span> <span class="n">DimensionDescription</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="s1">&#39;numeric&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_column_descriptors</span> <span class="o">=</span> <span class="p">[</span><span class="n">dim_description</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">check_bank</span><span class="p">:</span>
                <span class="n">all_units</span> <span class="o">=</span> <span class="n">check_bank_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">all_units</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">dim_description</span> <span class="o">=</span> <span class="n">DimensionDescription</span><span class="p">(</span><span class="n">label</span><span class="p">,</span>
                                                           <span class="s1">&#39;numeric&#39;</span><span class="p">,</span>
                                                           <span class="n">unit</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">units</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">dic</span> <span class="ow">in</span> <span class="n">all_units</span><span class="p">:</span>
                        <span class="n">units</span> <span class="o">+=</span> <span class="p">[</span><span class="n">dic</span><span class="p">[</span><span class="s1">&#39;unit&#39;</span><span class="p">],</span> <span class="n">dic</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]]</span>
                    <span class="n">dim_description</span> <span class="o">=</span> <span class="n">DimensionDescription</span><span class="p">(</span><span class="n">label</span><span class="p">,</span>
                                                           <span class="s1">&#39;numeric&#39;</span><span class="p">,</span>
                                                           <span class="n">units</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dim_description</span> <span class="o">=</span> <span class="n">DimensionDescription</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="s1">&#39;numeric&#39;</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_column_descriptors</span> <span class="o">=</span> <span class="p">[</span><span class="n">dim_description</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;unit must be a str or a list&quot;</span><span class="p">)</span>

    <span class="c1"># private property but with get access</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_categorical</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;MeasureHeader instances are all not categorical&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;main unit (i.e. with conversion value equal to 1)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_descriptors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;int or float, first value of the dimension&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;interval between the values of this dimension&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_elem</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;number of elements in the dimension&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_elem</span>

    <span class="c1"># methods</span>
    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;MeasureHeader&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Override the default Equals behavior&quot;&quot;&quot;</span>
        <span class="c1"># the two headers must have the same type</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">MeasureHeader</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">_label</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">_start</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_elem</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">_n_elem</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">_scale</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">self_descriptor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_descriptors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">other_descriptor</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_column_descriptors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">self_descriptor</span><span class="o">.</span><span class="n">label</span> <span class="o">!=</span> <span class="n">other_descriptor</span><span class="o">.</span><span class="n">label</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">self_descriptor</span><span class="o">.</span><span class="n">dimension_type</span> <span class="o">!=</span> <span class="n">other_descriptor</span><span class="o">.</span><span class="n">dimension_type</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">self_descriptor</span><span class="o">.</span><span class="n">unit</span> <span class="o">!=</span> <span class="n">other_descriptor</span><span class="o">.</span><span class="n">unit</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">self_descriptor</span><span class="o">.</span><span class="n">all_units</span> <span class="o">!=</span> <span class="n">other_descriptor</span><span class="o">.</span><span class="n">all_units</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">get_n_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns the number of columns&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">get_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;gives the unit if it exist, in the form of a list to be compatible</span>
<span class="sd">        with CategoricalHeaders&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_descriptors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;no unit&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_column_descriptors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">get_all_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;gives the conversion tables in the form of a list with a single</span>
<span class="sd">        element to be compatible with Categorical headers&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_column_descriptors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;no unit&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_column_descriptors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">all_units</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">disp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;display some information about the header&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;MeasureHeader: &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;unit: &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_units</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;start: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_start</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;scale: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;n_elem: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_elem</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;get the value of the line of number line of the first column&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">column</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">column</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Measure headers have only one column, column&quot;</span>
                            <span class="s2">&quot;argument must be None or 0&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;line must be of type int&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">line</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_elem</span> <span class="ow">or</span> <span class="n">line</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;line must be in [0, n_elem[&quot;</span><span class="p">)</span>
        <span class="c1"># Since we use python, we have decided that to access the first element</span>
        <span class="c1"># of the column, line must be equal to 0.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="o">+</span> <span class="n">line</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span>

    <span class="k">def</span> <span class="nf">get_item_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line_num</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;get the value(s) of the line(s) in line_num (it can be an int or a list</span>
<span class="sd">        of int), of the first column&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line_num</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">line_num</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_elem</span> <span class="ow">or</span> <span class="n">line_num</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;line_num must be in [0, n_elem[&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="n">line_num</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line_num</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">item_names</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">line_num</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;all line numbers must be integers&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_elem</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;line_num must be in [0, n_elem[&quot;</span><span class="p">)</span>
                <span class="n">item_names</span> <span class="o">+=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
            <span class="k">return</span> <span class="n">item_names</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;line_num must be an int or a list of int&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update_measure_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                              <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">n_elem</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;creates a new measure header from the attributes of a previous one,</span>
<span class="sd">        and the specified changes&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;start must be of type int or float&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_elem</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n_elem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_elem</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_elem</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;n_elem must be of type int&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;scale must be of type int or float&quot;</span><span class="p">)</span>
        <span class="k">return</span><span class="p">(</span><span class="n">MeasureHeader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">,</span>
                             <span class="n">start</span><span class="p">,</span>
                             <span class="n">n_elem</span><span class="p">,</span>
                             <span class="n">scale</span><span class="p">,</span>
                             <span class="n">column_descriptors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_column_descriptors</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    
    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;creates a copy of a measure header&quot;&quot;&quot;</span>
        <span class="n">descriptor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_descriptors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">MeasureHeader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">n_elem</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span>
                             <span class="n">column_descriptors</span><span class="o">=</span><span class="n">descriptor</span><span class="p">)</span></div>


<div class="viewcode-block" id="Xdata"><a class="viewcode-back" href="../xdata.html#xdata.Xdata">[docs]</a><span class="k">class</span> <span class="nc">Xdata</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;This class allows the creation of a ND dataset, with headers for each</span>
<span class="sd">    dimension and a name.</span>

<span class="sd">    Xdata is used to store the data. Xdata is a container for an ND</span>
<span class="sd">    (N dimensional) array with all the values/data, as well as all of the</span>
<span class="sd">    headers describing each of the N dimensions, stored in a list. Xdata also</span>
<span class="sd">    has the name of the whole set of data and a data_descriptor attribute to</span>
<span class="sd">    describe the data.</span>

<span class="sd">    Xdata includes a handling of events.</span>
<span class="sd">    TODO: explain better the event part</span>


<span class="sd">    **Parameters**</span>

<span class="sd">    - name:</span>
<span class="sd">        name of the dataset (type str)</span>
<span class="sd">    - data:</span>
<span class="sd">        N dimensional numpy array with the data itself</span>
<span class="sd">    - headers:</span>
<span class="sd">        list of the headers describing each of the N dimensions</span>
<span class="sd">    - unit:</span>
<span class="sd">        simple unit or list of conversion</span>

<span class="sd">    **Attributes**</span>

<span class="sd">    - data:</span>
<span class="sd">        N dimensional numpy.ndarray with the data itself</span>
<span class="sd">    - headers:</span>
<span class="sd">        list of the headers describing each of the N dimensions</span>
<span class="sd">    - name:</span>
<span class="sd">        name of the dataset (type str)</span>
<span class="sd">    - data_descriptor:</span>
<span class="sd">        DimensionDescription instance describing the dataset</span>

<span class="sd">    **Methods**</span>

<span class="sd">    - get_n_dimensions:</span>
<span class="sd">        gives the number of dimensions of xdata (it corresponds to the</span>
<span class="sd">        number of headers)</span>
<span class="sd">    - shape:</span>
<span class="sd">        gives the shape of the data (it corresponds to the number of elements</span>
<span class="sd">        for each dimension)</span>
<span class="sd">    - copy:</span>
<span class="sd">        creates a copy of a Xdata instance</span>
<span class="sd">    - update_data(new_data):</span>
<span class="sd">        Simply changing some values in data by giving a whole new numpy array.</span>
<span class="sd">        Those changes can change the length of measure headers or categorical</span>
<span class="sd">        headers that are undifferentiated. This method returns a new Xdata</span>
<span class="sd">        instance.</span>
<span class="sd">    - update_xdata(flag, dim, ind, data_slices, modified_header):</span>
<span class="sd">        - flag</span>
<span class="sd">            - &#39;data_chg&#39; to only change some data (it can modify the length of</span>
<span class="sd">              measure headers and undifferentiated headers but not</span>
<span class="sd">              categorical_with_values headers), this flag is not supposed to be</span>
<span class="sd">              used: to simply change the data, one must use update_data.</span>
<span class="sd">              However, the flag can be &#39;all&#39; but with no new header, in witch</span>
<span class="sd">              case, we transform it to the &#39;data_chg&#39; flag (this is why it is</span>
<span class="sd">              tolerated as an argument as well)</span>

<span class="sd">            - &#39;all&#39; to change the data and modify the header (possible</span>
<span class="sd">              modifications are given for modified_header)</span>

<span class="sd">            - &#39;chg&#39; to change some lines of a header and corresponding data</span>

<span class="sd">            - &#39;new&#39; to add lines in a dimension</span>

<span class="sd">            - &#39;remove&#39; to remove some lines</span>

<span class="sd">            - &#39;chg&amp;new&#39; to change and add some lines</span>

<span class="sd">            - &#39;chg&amp;rm&#39; to change and remove some lines</span>

<span class="sd">            - &#39;perm&#39; to permute some lines</span>

<span class="sd">       - dim:</span>
<span class="sd">            (int) number of the modified header</span>

<span class="sd">       - ind:</span>
<span class="sd">            (list of int) indices of lines that are changing</span>

<span class="sd">       - data_slices:</span>
<span class="sd">            new values for the modified lines</span>

<span class="sd">       - modified_header:</span>
<span class="sd">            same header as before but with a few changes (adding columns,</span>
<span class="sd">            lines, changing values depending of the type of header).</span>

<span class="sd">       This method allows to update a header and the corresponding data,</span>
<span class="sd">       the shape of data might be modified but the dimensions are still</span>
<span class="sd">       representing the same thing(DimensionDescriptions are not changed,</span>
<span class="sd">       (except for dimension_type that might become &#39;mixed&#39; if some lines are</span>
<span class="sd">       merged)).It returns a new data instance. TODO : change the returns part</span>

<span class="sd">    - modify_dimensions(flag, dim, new_data, new_headers):</span>
<span class="sd">        - flag</span>
<span class="sd">            - &#39;global&#39; to change everything,</span>
<span class="sd">            - &#39;dim_chg&#39; to change one dimension/dimensions,</span>
<span class="sd">            - &#39;dim_insert&#39; to insert a dimension/dimensions,</span>
<span class="sd">            - &#39;dim_rm&#39; to remove a dimension/dimensions,</span>
<span class="sd">            - &#39;dim_perm&#39; to permute the dimensions</span>

<span class="sd">        - dim:</span>
<span class="sd">            list of the dimensions to be changed</span>

<span class="sd">        - new_data:</span>
<span class="sd">            full numpy.array with the whole data (except for flag</span>
<span class="sd">            &#39;dim_perm&#39;)</span>

<span class="sd">        - new_headers:</span>
<span class="sd">            list of the new headers</span>

<span class="sd">        This methods allows to modify the structure of a Xdata instance, i.e.</span>
<span class="sd">        to modify the DimensionDescriptions in the list of headers (and</span>
<span class="sd">        therefore the data) new headers do not represent the same thing as</span>
<span class="sd">        before. This method also allows to change the number of dimensions.</span>
<span class="sd">        It returns a new Xdata instance. TODO : change the returns part</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">name</span><span class="p">,</span>
                 <span class="n">data</span><span class="p">,</span>
                 <span class="n">headers</span><span class="p">,</span>
                 <span class="n">unit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructor of the class Xdata&quot;&quot;&quot;</span>
        <span class="c1"># name must be a string</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;name must be of type str&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="c1"># data must be a numpy array and headers a list with the same length</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;data must be of type numpy.ndarray&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">headers</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;headers must be of type list&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">headers</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;each dimension must be described by a header&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">headers</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">headers</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="n">Header</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;headers must only contain header elements&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">headers</span><span class="p">[</span><span class="n">h</span><span class="p">]</span><span class="o">.</span><span class="n">n_elem</span> <span class="o">!=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">h</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;the number of elements must be the same in &quot;</span>
                                <span class="s2">&quot;the data and in the header&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_headers</span> <span class="o">=</span> <span class="n">headers</span>
        <span class="c1"># unit must allow creation of a DimensionDescription instance</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data_descriptor</span> <span class="o">=</span> <span class="n">DimensionDescription</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;numeric&#39;</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;unit must a string or a list of conversion&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;name of the data with the complementary information stored in</span>
<span class="sd">        headers and data_descriptor&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">headers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;list of the headers for each dimension&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_headers</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;ND numpy.array of numerical data&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data_descriptor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;DimensionDescription instance to describe the content of data&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_descriptor</span>

    <span class="k">def</span> <span class="nf">get_n_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;gives the number of dimensions of the data&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">headers</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;gives the number of element in each dimension&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;gives a copy of a Xdata instance&quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">headers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">headers</span><span class="p">:</span>
            <span class="n">headers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_descriptor</span><span class="o">.</span><span class="n">all_units</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_descriptor</span><span class="o">.</span><span class="n">all_units</span><span class="p">:</span>
                <span class="n">unit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="s1">&#39;unit&#39;</span><span class="p">])</span>
                <span class="n">unit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">Xdata</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creating a new Xdata instance, with updated data and the same</span>
<span class="sd">        headers as before (except for the length of some measure headers and</span>
<span class="sd">        undifferentiated headers)&quot;&quot;&quot;</span>
        <span class="c1"># checking the number of dimension</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_n_dimensions</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;update_data method does not allow to change the &quot;</span>
                            <span class="s2">&quot;number of dimensions, please use &quot;</span>
                            <span class="s2">&quot;modify_dimensions method instead&quot;</span><span class="p">)</span>
        <span class="c1"># for each dimension, check if the number of element has changed</span>
        <span class="c1"># if it has changed, make sure this change is allowed</span>
        <span class="c1"># if so, update the header</span>
        <span class="n">new_xdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_n_dimensions</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">new_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">n_elem</span><span class="p">:</span>
                <span class="n">old_h</span> <span class="o">=</span> <span class="n">new_xdata</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">is_categorical_with_values</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;categorical headers with values can&#39;t &quot;</span>
                                    <span class="s2">&quot;have new not defined elements&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">is_undifferentiated</span><span class="p">:</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="n">new_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">n_elem</span>
                    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([])]</span> <span class="o">*</span> <span class="n">n</span>
                        <span class="n">h</span> <span class="o">=</span> <span class="n">old_h</span><span class="o">.</span><span class="n">update_categorical_header</span><span class="p">(</span>
                            <span class="s1">&#39;new&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
                        <span class="n">new_xdata</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># the number element has decreased</span>
                        <span class="n">ind</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                        <span class="n">h</span> <span class="o">=</span> <span class="n">old_h</span><span class="o">.</span><span class="n">update_categorical_header</span><span class="p">(</span>
                            <span class="s1">&#39;rm&#39;</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                        <span class="n">new_xdata</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># the header is a measure header</span>
                    <span class="n">h</span> <span class="o">=</span> <span class="n">old_h</span><span class="o">.</span><span class="n">update_measure_header</span><span class="p">(</span>
                        <span class="n">n_elem</span><span class="o">=</span><span class="n">new_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dim</span><span class="p">])</span>
                    <span class="n">new_xdata</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span>

        <span class="c1"># once all headers are updated, update the data itself</span>
        <span class="n">new_xdata</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">new_data</span>
        <span class="k">return</span> <span class="n">new_xdata</span>
        <span class="c1"># TODO : notify instead of returns</span>

    <span class="k">def</span> <span class="nf">update_xdata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">data_slices</span><span class="p">,</span> <span class="n">modified_header</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;creates a new Xdata instance with the same attributes as the</span>
<span class="sd">        previous one, except for lines changed both in the data and the</span>
<span class="sd">        corresponding header&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;dim is of type int&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">dim</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">dim</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_n_dimensions</span><span class="p">()):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;dim must correspond to an existing dimension&quot;</span><span class="p">)</span>
        <span class="n">nd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_n_dimensions</span><span class="p">()</span>
        <span class="n">old_header</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
        <span class="c1"># for flag &#39;all&#39;: the whole content of the header has been modified</span>
        <span class="c1"># data_slices is a numpy array with all the data</span>
        <span class="c1"># check that flag &#39;all&#39; is not in fact a flag &#39;data_chg&#39;</span>
        <span class="k">if</span> <span class="n">flag</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="c1"># checking that ind is coherent</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">ind</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="nb">list</span><span class="p">))):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ind must be None, an empty list, or the list&quot;</span>
                                <span class="s2">&quot; of all indices&quot;</span><span class="p">)</span>
            <span class="c1"># checking that modified_header is a Header</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">modified_header</span><span class="p">,</span> <span class="n">Header</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;modified_header must be of type Header&quot;</span><span class="p">)</span>
            <span class="c1"># checking that flag is not in fact &#39;data_chg&#39;</span>
            <span class="c1"># i.e. that the header has changed</span>
            <span class="k">if</span> <span class="n">old_header</span> <span class="o">==</span> <span class="n">modified_header</span><span class="p">:</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="s1">&#39;data_chg&#39;</span>
            <span class="c1"># checking that data_slices can replace data</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_slices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;data_slices must be a numpy array for a flag &quot;</span>
                                <span class="s2">&quot;&#39;all&#39;&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_slices</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nd</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;data_slices must have the same number of &quot;</span>
                                <span class="s2">&quot;dimensions as data&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nd</span><span class="p">):</span>
                <span class="c1"># &#39;all&#39; flag does not change the number of elements in the</span>
                <span class="c1"># various dimensions except for the one that is being modified</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">dim</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">data_slices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">!=</span> <span class="n">modified_header</span><span class="o">.</span><span class="n">n_elem</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;the new data and the new header must&quot;</span>
                                        <span class="s2">&quot; have the same number of elements in&quot;</span>
                                        <span class="s2">&quot; the concerned dimension&quot;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">modified_header</span><span class="o">.</span><span class="n">label</span> <span class="o">!=</span> <span class="n">old_header</span><span class="o">.</span><span class="n">label</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;label of the header can&#39;t be changed&quot;</span>
                                        <span class="s2">&quot; with this method&quot;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">old_header</span><span class="o">.</span><span class="n">is_measure</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">modified_header</span><span class="o">.</span><span class="n">unit</span> <span class="o">!=</span> <span class="n">old_header</span><span class="o">.</span><span class="n">unit</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;flag &#39;all&#39; can&#39;t change the unit&quot;</span>
                                            <span class="s2">&quot; of the header&quot;</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">modified_header</span><span class="o">.</span><span class="n">all_units</span> <span class="o">!=</span> <span class="n">old_header</span><span class="o">.</span><span class="n">all_units</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;flag &#39;all&#39; can&#39;t change the unit&quot;</span>
                                            <span class="s2">&quot; of the header&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">data_slices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">()[</span><span class="n">n</span><span class="p">]:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&#39;all&#39; flag only allows one dimension&quot;</span>
                                        <span class="s2">&quot; to change its number of elements&quot;</span><span class="p">)</span>
            <span class="n">new_xdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">new_xdata</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data_slices</span>
            <span class="n">new_xdata</span><span class="o">.</span><span class="n">_headers</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">modified_header</span>
            <span class="k">return</span> <span class="n">new_xdata</span><span class="p">,</span> <span class="n">flag</span>

        <span class="k">if</span> <span class="n">flag</span> <span class="o">==</span> <span class="s1">&#39;data_chg&#39;</span><span class="p">:</span>
            <span class="c1"># This flag is not supposed to be used except if the given flag was</span>
            <span class="c1"># &#39;all&#39; but the header was the same</span>

            <span class="c1"># header must be None or the same as the old one</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">modified_header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="p">(</span><span class="n">modified_header</span> <span class="o">==</span> <span class="n">old_header</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&#39;data_chg&#39; flag can&#39;t change the header&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">ind</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="nb">list</span><span class="p">))):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ind must be None, an empty list, or the list&quot;</span>
                                <span class="s2">&quot; of all indices&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_slices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;data_slices must be a numpy array for a flag &quot;</span>
                                <span class="s2">&quot;&#39;data_chg&#39;&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">data_slices</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;flag &#39;data_chg&#39; can&#39;t change the dimensions &quot;</span>
                                <span class="s2">&quot;nor number of elements in the dimensions&quot;</span><span class="p">)</span>
            <span class="n">new_xdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">new_xdata</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data_slices</span>
            <span class="k">return</span> <span class="n">new_xdata</span><span class="p">,</span> <span class="n">flag</span>

        <span class="k">elif</span> <span class="n">flag</span> <span class="o">==</span> <span class="s1">&#39;chg&#39;</span><span class="p">:</span>
            <span class="c1"># lets first check the header</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">modified_header</span><span class="p">,</span> <span class="n">Header</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;modified_header must be of type Header&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">modified_header</span><span class="o">.</span><span class="n">is_measure</span> <span class="ow">or</span>
                  <span class="n">modified_header</span><span class="o">.</span><span class="n">is_undifferentiated</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">modified_header</span> <span class="o">!=</span> <span class="n">old_header</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;measure headers and undifferentiated &quot;</span>
                                    <span class="s2">&quot;ones can&#39;t be modified by a flag &#39;chg&#39;&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># then it&#39;s a categorical_with_values header</span>
                <span class="k">if</span> <span class="n">old_header</span><span class="o">.</span><span class="n">n_elem</span> <span class="o">!=</span> <span class="n">modified_header</span><span class="o">.</span><span class="n">n_elem</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&#39;chg&#39; flag can&#39;t change the number of &quot;</span>
                                    <span class="s2">&quot;elements in the dimension&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">old_header</span><span class="o">.</span><span class="n">get_n_columns</span><span class="p">()</span> <span class="o">!=</span>
                        <span class="n">modified_header</span><span class="o">.</span><span class="n">get_n_columns</span><span class="p">()):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&#39;chg&#39; flag can&#39;t change the number of &quot;</span>
                                    <span class="s2">&quot;columns of the header&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">old_header</span><span class="o">.</span><span class="n">get_all_units</span><span class="p">()</span> <span class="o">!=</span>
                        <span class="n">modified_header</span><span class="o">.</span><span class="n">get_all_units</span><span class="p">()):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&#39;chg&#39; flag can&#39;t change the units&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">old_header</span><span class="o">.</span><span class="n">label</span> <span class="o">!=</span> <span class="n">modified_header</span><span class="o">.</span><span class="n">label</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&#39;chg&#39; flag can&#39;t change labels&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">old_header</span><span class="o">.</span><span class="n">get_n_columns</span><span class="p">()):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">old_header</span><span class="o">.</span><span class="n">column_descriptors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">label</span> <span class="o">!=</span>
                            <span class="n">modified_header</span><span class="o">.</span><span class="n">column_descriptors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&#39;chg&#39; flag can&#39;t change labels&quot;</span><span class="p">)</span>
            <span class="c1"># note: we didn&#39;t check that the values haven&#39;t changed for the</span>
            <span class="c1"># lines that are not supposed to be modified in order to fasten the</span>
            <span class="c1"># update for huge sets of data. Such changes are usually done by</span>
            <span class="c1"># filters, that are tested to do the right thing</span>

            <span class="c1"># now lets check that ind and data_slices have correct type and</span>
            <span class="c1"># same length</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ind must be of type list&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_slices</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;data_slices must be of type list&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_slices</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;data_slices must have the same number of &quot;</span>
                                <span class="s2">&quot;element as ind&quot;</span><span class="p">)</span>
            <span class="n">new_xdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">change_slice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_n_dimensions</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)):</span>
                <span class="n">change_slice</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;all indices must be of type int&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_slices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;all data_slices must be of type &quot;</span>
                                    <span class="s2">&quot;numpy.ndarray&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;data_slice doesn&#39;t have a correct shape&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">dim</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">data_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;data_slice doesn&#39;t have a correct&quot;</span>
                                            <span class="s2">&quot; number of elements&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">dim</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">data_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;data_slice doesn&#39;t have a correct&quot;</span>
                                            <span class="s2">&quot; number of elements&quot;</span><span class="p">)</span>
                <span class="c1"># now lets modify the data ...</span>
                <span class="n">new_xdata</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">change_slice</span><span class="p">)]</span> <span class="o">=</span> <span class="n">data_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1"># ...and replace the header</span>
            <span class="n">new_xdata</span><span class="o">.</span><span class="n">_headers</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">modified_header</span>
            <span class="k">return</span> <span class="n">new_xdata</span><span class="p">,</span> <span class="n">flag</span>

        <span class="k">elif</span> <span class="n">flag</span> <span class="o">==</span> <span class="s1">&#39;new&#39;</span><span class="p">:</span>
            <span class="c1"># lets first test ind</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">ind</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ind must be None, or an empty list, or the &quot;</span>
                                <span class="s2">&quot;list of new indices&quot;</span><span class="p">)</span>
            <span class="c1"># now lets check data_slices</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_slices</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;data_slices must be of type list&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_slices</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_slices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;all data_slices must be of type &quot;</span>
                                    <span class="s2">&quot;numpy.ndarray&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;data_slice doesn&#39;t have a correct shape&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">dim</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">data_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;data_slice doesn&#39;t have a correct&quot;</span>
                                            <span class="s2">&quot; number of elements&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">dim</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">data_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;data_slice doesn&#39;t have a correct&quot;</span>
                                            <span class="s2">&quot; number of elements&quot;</span><span class="p">)</span>
            <span class="c1"># now we check the header</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">modified_header</span><span class="p">,</span> <span class="n">Header</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;modified_header must be of type Header&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">modified_header</span><span class="o">.</span><span class="n">is_measure</span> <span class="o">!=</span> <span class="n">old_header</span><span class="o">.</span><span class="n">is_measure</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                    <span class="n">modified_header</span><span class="o">.</span><span class="n">is_undifferentiated</span> <span class="o">!=</span>
                    <span class="n">old_header</span><span class="o">.</span><span class="n">is_undifferentiated</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;header can&#39;t change its type with flag &#39;new&#39;&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">modified_header</span><span class="o">.</span><span class="n">n_elem</span> <span class="o">!=</span> <span class="n">old_header</span><span class="o">.</span><span class="n">n_elem</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_slices</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;the number of elements added in a &quot;</span>
                                    <span class="s2">&quot;dimension must be the same in data and &quot;</span>
                                    <span class="s2">&quot;in the header&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">modified_header</span><span class="o">.</span><span class="n">is_categorical_with_values</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">old_header</span><span class="o">.</span><span class="n">get_n_columns</span><span class="p">()</span> <span class="o">!=</span>
                        <span class="n">modified_header</span><span class="o">.</span><span class="n">get_n_columns</span><span class="p">()):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&#39;new&#39; flag can&#39;t change the number of &quot;</span>
                                    <span class="s2">&quot;columns of the header&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">old_header</span><span class="o">.</span><span class="n">get_all_units</span><span class="p">()</span> <span class="o">!=</span>
                        <span class="n">modified_header</span><span class="o">.</span><span class="n">get_all_units</span><span class="p">()):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&#39;new&#39; flag can&#39;t change the units&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">old_header</span><span class="o">.</span><span class="n">label</span> <span class="o">!=</span> <span class="n">modified_header</span><span class="o">.</span><span class="n">label</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&#39;new&#39; flag can&#39;t change labels&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">old_header</span><span class="o">.</span><span class="n">get_n_columns</span><span class="p">()):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">old_header</span><span class="o">.</span><span class="n">column_descriptors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">label</span> <span class="o">!=</span>
                            <span class="n">modified_header</span><span class="o">.</span><span class="n">column_descriptors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&#39;new&#39; flag can&#39;t change labels&quot;</span><span class="p">)</span>
            <span class="c1"># note: we didn&#39;t check that the values haven&#39;t changed for the</span>
            <span class="c1"># lines that are not supposed to be modified in order to fasten the</span>
            <span class="c1"># update for huge sets of data. Such changes are usually done by</span>
            <span class="c1"># filters, that are tested to do the right thing</span>
            <span class="n">new_xdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># Now lets replace the header</span>
            <span class="n">new_xdata</span><span class="o">.</span><span class="n">_headers</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">modified_header</span>
            <span class="c1"># And recreate the data (can&#39;t change the size of a numpy array)</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">())</span>
            <span class="n">shape</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_slices</span><span class="p">)</span>
            <span class="n">new_data_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
            <span class="n">old_data</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nd</span>
            <span class="n">old_data</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_headers</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">n_elem</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">new_xdata</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">new_data_array</span>
            <span class="n">new_xdata</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">old_data</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_slices</span><span class="p">)):</span>
                <span class="n">new_data</span> <span class="o">=</span> <span class="n">old_data</span>
                <span class="n">new_data</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_headers</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">n_elem</span> <span class="o">+</span> <span class="n">i</span>
                <span class="n">slice_of_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">data_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                <span class="n">new_xdata</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">new_data</span><span class="p">)]</span> <span class="o">=</span> <span class="n">slice_of_data</span>
            <span class="k">return</span> <span class="n">new_xdata</span><span class="p">,</span> <span class="n">flag</span>

        <span class="k">elif</span> <span class="n">flag</span> <span class="o">==</span> <span class="s1">&#39;remove&#39;</span><span class="p">:</span>
            <span class="c1"># lets first check that ind and data_slices has correct type</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ind must be of type list&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="p">((</span><span class="n">data_slices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">data_slices</span> <span class="o">==</span> <span class="p">[])):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;data_slices must be empty&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;all indices must be of type int&quot;</span><span class="p">)</span>
            <span class="c1"># now lets check the header and its number of elements</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">modified_header</span><span class="p">,</span> <span class="n">Header</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;modified_header must be of type Header&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">modified_header</span><span class="o">.</span><span class="n">is_measure</span> <span class="o">!=</span> <span class="n">old_header</span><span class="o">.</span><span class="n">is_measure</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                    <span class="n">modified_header</span><span class="o">.</span><span class="n">is_undifferentiated</span> <span class="o">!=</span>
                    <span class="n">old_header</span><span class="o">.</span><span class="n">is_undifferentiated</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;header can&#39;t change its type with flag &quot;</span>
                                <span class="s2">&quot;&#39;remove&#39;&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">modified_header</span><span class="o">.</span><span class="n">n_elem</span> <span class="o">!=</span> <span class="n">old_header</span><span class="o">.</span><span class="n">n_elem</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;the number of elements removed in a &quot;</span>
                                    <span class="s2">&quot;dimension must be the same in data and &quot;</span>
                                    <span class="s2">&quot;in the header&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">modified_header</span><span class="o">.</span><span class="n">is_categorical_with_values</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">old_header</span><span class="o">.</span><span class="n">get_n_columns</span><span class="p">()</span> <span class="o">!=</span>
                        <span class="n">modified_header</span><span class="o">.</span><span class="n">get_n_columns</span><span class="p">()):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&#39;remove&#39; flag can&#39;t change the number of&quot;</span>
                                    <span class="s2">&quot; columns of the header&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">old_header</span><span class="o">.</span><span class="n">get_all_units</span><span class="p">()</span> <span class="o">!=</span>
                        <span class="n">modified_header</span><span class="o">.</span><span class="n">get_all_units</span><span class="p">()):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&#39;remove&#39; flag can&#39;t change the units&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">old_header</span><span class="o">.</span><span class="n">label</span> <span class="o">!=</span> <span class="n">modified_header</span><span class="o">.</span><span class="n">label</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&#39;remove&#39; flag can&#39;t change labels&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">old_header</span><span class="o">.</span><span class="n">get_n_columns</span><span class="p">()):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">old_header</span><span class="o">.</span><span class="n">column_descriptors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">label</span> <span class="o">!=</span>
                            <span class="n">modified_header</span><span class="o">.</span><span class="n">column_descriptors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&#39;remove&#39; flag can&#39;t change labels&quot;</span><span class="p">)</span>
            <span class="c1"># note: we didn&#39;t check that the values haven&#39;t changed for the</span>
            <span class="c1"># lines that are not supposed to be modified in order to fasten the</span>
            <span class="c1"># update for huge sets of data. Such changes are usually done by</span>
            <span class="c1"># filters, that are tested to do the right thing</span>
            <span class="n">new_xdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># Now lets replace the header</span>
            <span class="n">new_xdata</span><span class="o">.</span><span class="n">_headers</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">modified_header</span>
            <span class="n">new_xdata</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">new_xdata</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new_xdata</span><span class="p">,</span> <span class="n">flag</span>

        <span class="k">elif</span> <span class="n">flag</span> <span class="o">==</span> <span class="s1">&#39;chg&amp;new&#39;</span><span class="p">:</span>
            <span class="c1"># lets first check data_slices</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_slices</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;data_slices must be a list of two elements: &quot;</span>
                                <span class="s2">&quot;first the list of the lines that have &quot;</span>
                                <span class="s2">&quot;changed, second the list of new lines&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_slices</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;data_slices must be a list of two elements: &quot;</span>
                                <span class="s2">&quot;first the list of the lines that have &quot;</span>
                                <span class="s2">&quot;changed, second the list of new lines&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">data_slices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span>
                      <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_slices</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">list</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;data_slices must be a list of two elements: &quot;</span>
                                <span class="s2">&quot;first the list of the lines that have &quot;</span>
                                <span class="s2">&quot;changed, second the list of new lines&quot;</span><span class="p">)</span>
            <span class="c1"># now lets check ind</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ind must be the list of indices of the lines&quot;</span>
                                <span class="s2">&quot; to be changed&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ind must be the list of indices of the &quot;</span>
                                    <span class="s2">&quot;lines to be changed&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="p">((</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">list</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;the list of new lines to add must be &quot;</span>
                                    <span class="s2">&quot;empty,, None or the list of the indices&quot;</span><span class="p">)</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># now lets check the modified header and check that the length of</span>
            <span class="c1"># the arguments is coherent</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">modified_header</span><span class="p">,</span> <span class="n">Header</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;modified_header must be of type Header&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">modified_header</span><span class="o">.</span><span class="n">is_measure</span> <span class="o">!=</span> <span class="n">old_header</span><span class="o">.</span><span class="n">is_measure</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                    <span class="n">modified_header</span><span class="o">.</span><span class="n">is_undifferentiated</span> <span class="o">!=</span>
                    <span class="n">old_header</span><span class="o">.</span><span class="n">is_undifferentiated</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;header can&#39;t change its type with flag &quot;</span>
                                <span class="s2">&quot;&#39;chg&amp;new&#39;&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">modified_header</span><span class="o">.</span><span class="n">n_elem</span> <span class="o">!=</span>
                    <span class="n">old_header</span><span class="o">.</span><span class="n">n_elem</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_slices</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;the number of elements added in a &quot;</span>
                                <span class="s2">&quot;dimension must be the same in data and &quot;</span>
                                <span class="s2">&quot;in the header&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">modified_header</span><span class="o">.</span><span class="n">is_categorical_with_values</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">old_header</span><span class="o">.</span><span class="n">get_n_columns</span><span class="p">()</span> <span class="o">!=</span>
                        <span class="n">modified_header</span><span class="o">.</span><span class="n">get_n_columns</span><span class="p">()):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&#39;chg&amp;new&#39; flag can&#39;t change the number &quot;</span>
                                    <span class="s2">&quot;of columns of the header&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">old_header</span><span class="o">.</span><span class="n">get_all_units</span><span class="p">()</span> <span class="o">!=</span>
                        <span class="n">modified_header</span><span class="o">.</span><span class="n">get_all_units</span><span class="p">()):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&#39;chg&amp;new&#39; flag can&#39;t change the units&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">old_header</span><span class="o">.</span><span class="n">label</span> <span class="o">!=</span> <span class="n">modified_header</span><span class="o">.</span><span class="n">label</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&#39;chg&amp;new&#39; flag can&#39;t change labels&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">old_header</span><span class="o">.</span><span class="n">get_n_columns</span><span class="p">()):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">old_header</span><span class="o">.</span><span class="n">column_descriptors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">label</span> <span class="o">!=</span>
                            <span class="n">modified_header</span><span class="o">.</span><span class="n">column_descriptors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&#39;chg&amp;new&#39; flag can&#39;t change labels&quot;</span><span class="p">)</span>
            <span class="c1"># note: we didn&#39;t check that the values haven&#39;t changed for the</span>
            <span class="c1"># lines that are not supposed to be modified in order to fasten the</span>
            <span class="c1"># update for huge sets of data. Such changes are usually done by</span>
            <span class="c1"># filters, that are tested to do the right thing</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_slices</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;all changed slices must be given new values&quot;</span><span class="p">)</span>

            <span class="n">new_xdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">new_xdata</span><span class="o">.</span><span class="n">_headers</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">modified_header</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">())</span>
            <span class="n">shape</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_slices</span><span class="p">)</span>
            <span class="n">new_data_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
            <span class="n">old_data</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nd</span>
            <span class="n">old_data</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_headers</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">n_elem</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">new_xdata</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">new_data_array</span>
            <span class="c1"># lets copy the &#39;old&#39; values</span>
            <span class="n">new_xdata</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">old_data</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
            <span class="c1"># and change the lines before adding the new ones</span>
            <span class="n">change_slice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nd</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)):</span>
                <span class="n">change_slice</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;all indices must be of type int&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_slices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;all data_slices must be of type &quot;</span>
                                    <span class="s2">&quot;numpy.ndarray&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_slices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;data_slice doesn&#39;t have a correct shape&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_slices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">dim</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">data_slices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;data_slice doesn&#39;t have a correct&quot;</span>
                                            <span class="s2">&quot; number of elements&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">dim</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">data_slices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]):</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;data_slice doesn&#39;t have a correct&quot;</span>
                                            <span class="s2">&quot; number of elements&quot;</span><span class="p">)</span>
                <span class="c1"># slices and indices are correct, lets modify the data</span>
                <span class="n">new_xdata</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">change_slice</span><span class="p">)]</span> <span class="o">=</span> <span class="n">data_slices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="c1"># now lets add the new lines</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_slices</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_slices</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;all data_slices must be of type &quot;</span>
                                    <span class="s2">&quot;numpy.ndarray&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_slices</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;data_slice doesn&#39;t have a correct shape&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_slices</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">dim</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">data_slices</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;data_slice doesn&#39;t have a correct&quot;</span>
                                            <span class="s2">&quot; number of elements&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">dim</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">data_slices</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]):</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;data_slice doesn&#39;t have a correct&quot;</span>
                                            <span class="s2">&quot; number of elements&quot;</span><span class="p">)</span>

                <span class="n">new_data</span> <span class="o">=</span> <span class="n">old_data</span>
                <span class="n">new_data</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_headers</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">n_elem</span> <span class="o">+</span> <span class="n">i</span>
                <span class="n">slice_of_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">data_slices</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]])</span>
                <span class="n">new_xdata</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">new_data</span><span class="p">)]</span> <span class="o">=</span> <span class="n">slice_of_data</span>
            <span class="k">return</span> <span class="n">new_xdata</span><span class="p">,</span> <span class="n">flag</span>

        <span class="k">elif</span> <span class="n">flag</span> <span class="o">==</span> <span class="s1">&#39;chg&amp;rm&#39;</span><span class="p">:</span>
            <span class="c1"># lets first check data_slices</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_slices</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;data_slices must be a list of the lines to &quot;</span>
                                <span class="s2">&quot;change&quot;</span><span class="p">)</span>
            <span class="c1"># now lets check ind</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span>
                    <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">list</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ind must be the list of the list of indices &quot;</span>
                                <span class="s2">&quot;of the lines to be changed and the list of &quot;</span>
                                <span class="s2">&quot;the lines to be removed&quot;</span><span class="p">)</span>
            <span class="c1"># now lets check the modified header and check that the length of</span>
            <span class="c1"># the arguments is coherent</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">modified_header</span><span class="p">,</span> <span class="n">Header</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;modified_header must be of type Header&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">modified_header</span><span class="o">.</span><span class="n">is_measure</span> <span class="o">!=</span> <span class="n">old_header</span><span class="o">.</span><span class="n">is_measure</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                    <span class="n">modified_header</span><span class="o">.</span><span class="n">is_undifferentiated</span> <span class="o">!=</span>
                    <span class="n">old_header</span><span class="o">.</span><span class="n">is_undifferentiated</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;header can&#39;t change its type with flag &quot;</span>
                                <span class="s2">&quot;&#39;chg&amp;rm&#39;&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">modified_header</span><span class="o">.</span><span class="n">n_elem</span> <span class="o">!=</span> <span class="n">old_header</span><span class="o">.</span><span class="n">n_elem</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;the number of elements removed in a &quot;</span>
                                    <span class="s2">&quot;dimension must be the same in data and &quot;</span>
                                    <span class="s2">&quot;in the header&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">modified_header</span><span class="o">.</span><span class="n">is_categorical_with_values</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">old_header</span><span class="o">.</span><span class="n">get_n_columns</span><span class="p">()</span> <span class="o">!=</span>
                        <span class="n">modified_header</span><span class="o">.</span><span class="n">get_n_columns</span><span class="p">()):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&#39;chg&amp;rm&#39; flag can&#39;t change the number &quot;</span>
                                    <span class="s2">&quot;of columns of the header&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">old_header</span><span class="o">.</span><span class="n">get_all_units</span><span class="p">()</span> <span class="o">!=</span>
                        <span class="n">modified_header</span><span class="o">.</span><span class="n">get_all_units</span><span class="p">()):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&#39;chg&amp;rm&#39; flag can&#39;t change the units&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">old_header</span><span class="o">.</span><span class="n">label</span> <span class="o">!=</span> <span class="n">modified_header</span><span class="o">.</span><span class="n">label</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&#39;chg&amp;rm&#39; flag can&#39;t change labels&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">old_header</span><span class="o">.</span><span class="n">get_n_columns</span><span class="p">()):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">old_header</span><span class="o">.</span><span class="n">column_descriptors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">label</span> <span class="o">!=</span>
                            <span class="n">modified_header</span><span class="o">.</span><span class="n">column_descriptors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&#39;chg&amp;rm&#39; flag can&#39;t change labels&quot;</span><span class="p">)</span>
            <span class="c1"># note: we didn&#39;t check that the values haven&#39;t changed for the</span>
            <span class="c1"># lines that are not supposed to be modified in order to fasten the</span>
            <span class="c1"># update for huge sets of data. Such changes are usually done by</span>
            <span class="c1"># filters, that are tested to do the right thing</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_slices</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;all changed slices must be given new values&quot;</span><span class="p">)</span>

            <span class="n">new_xdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">new_xdata</span><span class="o">.</span><span class="n">_headers</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">modified_header</span>
            <span class="c1"># let&#39;s change the lines before removing some</span>
            <span class="n">change_slice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nd</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)):</span>
                <span class="n">change_slice</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;all indices must be of type int&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_slices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;all data_slices must be of type &quot;</span>
                                    <span class="s2">&quot;numpy.ndarray&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;data_slice doesn&#39;t have a correct shape&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">dim</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">data_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;data_slice doesn&#39;t have a correct&quot;</span>
                                            <span class="s2">&quot; number of elements&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">dim</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">data_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;data_slice doesn&#39;t have a correct&quot;</span>
                                            <span class="s2">&quot; number of elements&quot;</span><span class="p">)</span>
                <span class="c1"># slices and indices are correct, lets modify the data</span>
                <span class="n">new_xdata</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">change_slice</span><span class="p">)]</span> <span class="o">=</span> <span class="n">data_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1"># now lets remove the lines we don&#39;t want to keep</span>
            <span class="n">new_xdata</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">new_xdata</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dim</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new_xdata</span><span class="p">,</span> <span class="n">flag</span>
        <span class="k">elif</span> <span class="n">flag</span> <span class="o">==</span> <span class="s1">&#39;perm&#39;</span><span class="p">:</span>
            <span class="c1"># data_slices must be None, because all the values will be</span>
            <span class="c1"># calculated from the permutation</span>
            <span class="k">if</span> <span class="n">data_slices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;data_slices must be None for a &#39;perm&#39; flag&quot;</span><span class="p">)</span>
            <span class="c1"># now let&#39;s check the Header</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">modified_header</span><span class="p">,</span> <span class="n">Header</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;modified_header must be of type Header&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">modified_header</span><span class="o">.</span><span class="n">is_measure</span> <span class="ow">or</span>
                    <span class="n">modified_header</span><span class="o">.</span><span class="n">is_undifferentiated</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">modified_header</span> <span class="o">!=</span> <span class="n">old_header</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;measure headers and undifferentiated &quot;</span>
                                    <span class="s2">&quot;ones can&#39;t be modified by a flag &#39;perm&#39;&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># then it&#39;s a categorical_with_values header</span>
                <span class="k">if</span> <span class="n">old_header</span><span class="o">.</span><span class="n">n_elem</span> <span class="o">!=</span> <span class="n">modified_header</span><span class="o">.</span><span class="n">n_elem</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&#39;perm&#39; flag can&#39;t change the number of &quot;</span>
                                    <span class="s2">&quot;elements in the dimension&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">old_header</span><span class="o">.</span><span class="n">get_n_columns</span><span class="p">()</span> <span class="o">!=</span>
                        <span class="n">modified_header</span><span class="o">.</span><span class="n">get_n_columns</span><span class="p">()):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&#39;perm&#39; flag can&#39;t change the number of &quot;</span>
                                    <span class="s2">&quot;columns of the header&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">old_header</span><span class="o">.</span><span class="n">get_all_units</span><span class="p">()</span> <span class="o">!=</span>
                        <span class="n">modified_header</span><span class="o">.</span><span class="n">get_all_units</span><span class="p">()):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&#39;perm&#39; flag can&#39;t change the units&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">old_header</span><span class="o">.</span><span class="n">label</span> <span class="o">!=</span> <span class="n">modified_header</span><span class="o">.</span><span class="n">label</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&#39;perm&#39; flag can&#39;t change labels&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">old_header</span><span class="o">.</span><span class="n">get_n_columns</span><span class="p">()):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">old_header</span><span class="o">.</span><span class="n">column_descriptors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">label</span> <span class="o">!=</span>
                            <span class="n">modified_header</span><span class="o">.</span><span class="n">column_descriptors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;&#39;perm&#39; flag can&#39;t change labels&quot;</span><span class="p">)</span>
            <span class="c1"># note: we didn&#39;t check that the values haven&#39;t changed for the</span>
            <span class="c1"># lines that are not supposed to be modified in order to fasten the</span>
            <span class="c1"># update for huge sets of data. Such changes are usually done by</span>
            <span class="c1"># filters, that are tested to do the right thing</span>

            <span class="c1"># now lets check that ind is a permutation of the indices of the</span>
            <span class="c1"># lines</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">n_elem</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ind is not a permutation of the indices&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">n_elem</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ind is not a permutation of the indices&quot;</span><span class="p">)</span>
            <span class="c1"># now lets permute the data and replace the header</span>
            <span class="n">new_xdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">new_xdata</span><span class="o">.</span><span class="n">_headers</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">modified_header</span>
            <span class="n">permute_slice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nd</span>
            <span class="n">old_slice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nd</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="c1"># this test saves some time if not all the lines are</span>
                    <span class="c1"># permuted</span>
                    <span class="n">permute_slice</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">old_slice</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="n">new_xdata</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">permute_slice</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">old_slice</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">new_xdata</span><span class="p">,</span> <span class="n">flag</span>
        <span class="c1"># all accepted flags with this method are already taken care of</span>
        <span class="c1"># flag argument is either not a flag or not one accepted by this method</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;flag must be &#39;all&#39;, &#39;chg&#39;, &#39;new&#39;, &#39;remove&#39;, &#39;perm&#39; &quot;</span>
                        <span class="s2">&quot;&#39;chg&amp;new&#39; or &#39;chg&amp;rm&#39;&quot;</span><span class="p">)</span>
        <span class="c1"># TODO : notify instead of returns</span>

    <span class="k">def</span> <span class="nf">modify_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">new_data</span><span class="p">,</span> <span class="n">new_headers</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;creates a new Xdata instance with changes for the dimensions&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">flag</span> <span class="o">==</span> <span class="s1">&#39;global&#39;</span><span class="p">:</span>
            <span class="c1"># lets first check that dim is coherent</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dim</span> <span class="o">!=</span> <span class="p">[]:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;for a &#39;global&#39; flag, everything is replaced,&quot;</span>
                                <span class="s2">&quot; dim must be empty&quot;</span><span class="p">)</span>
            <span class="c1"># other checks will be done in the constructor</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_descriptor</span><span class="o">.</span><span class="n">all_units</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">unit</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unit</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_descriptor</span><span class="o">.</span><span class="n">all_units</span><span class="p">:</span>
                    <span class="n">unit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="s1">&#39;unit&#39;</span><span class="p">])</span>
                    <span class="n">unit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>
            <span class="n">new_xdata</span> <span class="o">=</span> <span class="n">Xdata</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">new_data</span><span class="p">,</span> <span class="n">new_headers</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new_xdata</span><span class="p">,</span> <span class="n">flag</span>

        <span class="k">elif</span> <span class="n">flag</span> <span class="o">==</span> <span class="s1">&#39;dim_chg&#39;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">headers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">headers</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_headers</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;dim must have the same length as &quot;</span>
                                    <span class="s2">&quot;new_headers&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dim</span><span class="p">)):</span>
                    <span class="n">headers</span><span class="p">[</span><span class="n">dim</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">new_headers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_descriptor</span><span class="o">.</span><span class="n">all_units</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">unit</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">unit</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_descriptor</span><span class="o">.</span><span class="n">all_units</span><span class="p">:</span>
                        <span class="n">unit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="s1">&#39;unit&#39;</span><span class="p">])</span>
                        <span class="n">unit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>
                <span class="n">new_xdata</span> <span class="o">=</span> <span class="n">Xdata</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">new_data</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">new_xdata</span><span class="p">,</span> <span class="n">flag</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;incorrect arguments&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">flag</span> <span class="o">==</span> <span class="s1">&#39;dim_insert&#39;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">headers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">headers</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_headers</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;dim must have the same length as &quot;</span>
                                    <span class="s2">&quot;new_headers&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dim</span><span class="p">)):</span>
                    <span class="c1"># like the insert method for lists, if the index is out</span>
                    <span class="c1"># of range, the new element will just be appended at the</span>
                    <span class="c1"># end of the xdata element</span>
                    <span class="n">headers</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">dim</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">new_headers</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_descriptor</span><span class="o">.</span><span class="n">all_units</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">unit</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">unit</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_descriptor</span><span class="o">.</span><span class="n">all_units</span><span class="p">:</span>
                        <span class="n">unit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="s1">&#39;unit&#39;</span><span class="p">])</span>
                        <span class="n">unit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>
                <span class="n">new_xdata</span> <span class="o">=</span> <span class="n">Xdata</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">new_data</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">new_xdata</span><span class="p">,</span> <span class="n">flag</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;incorrect arguments&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">flag</span> <span class="o">==</span> <span class="s1">&#39;dim_rm&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">new_headers</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">new_headers</span> <span class="o">==</span> <span class="p">[]):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;when removing dimensions, no new dimension &quot;</span>
                                <span class="s2">&quot;must be given&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">headers</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_n_dimensions</span><span class="p">()</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_data</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;dim must the number of dimensions to &quot;</span>
                                    <span class="s2">&quot;remove&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">headers</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dim</span><span class="p">:</span>
                        <span class="n">headers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_descriptor</span><span class="o">.</span><span class="n">all_units</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">unit</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">unit</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_descriptor</span><span class="o">.</span><span class="n">all_units</span><span class="p">:</span>
                        <span class="n">unit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="s1">&#39;unit&#39;</span><span class="p">])</span>
                        <span class="n">unit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>
                <span class="n">new_xdata</span> <span class="o">=</span> <span class="n">Xdata</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">new_data</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">new_xdata</span><span class="p">,</span> <span class="n">flag</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;incorrect arguments&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">flag</span> <span class="o">==</span> <span class="s1">&#39;dim_perm&#39;</span><span class="p">:</span>
            <span class="c1"># lets first check that dim is a permutation of the dimensions</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">headers</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;dim is not a permutation of the dimensions&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">headers</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dim</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;dim is not a permutation of the &quot;</span>
                                    <span class="s2">&quot;dimensions&quot;</span><span class="p">)</span>
            <span class="c1"># now lets build the headers and the data if they are not given</span>
            <span class="k">if</span> <span class="n">new_headers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_headers</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dim</span><span class="p">:</span>
                    <span class="n">new_headers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">new_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
            <span class="c1"># if new_headers or new_data is given, it&#39;s not checked in order to</span>
            <span class="c1"># save some computation time</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_descriptor</span><span class="o">.</span><span class="n">all_units</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">unit</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unit</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_descriptor</span><span class="o">.</span><span class="n">all_units</span><span class="p">:</span>
                    <span class="n">unit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="s1">&#39;unit&#39;</span><span class="p">])</span>
                    <span class="n">unit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">new_xdata</span> <span class="o">=</span> <span class="n">Xdata</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">new_data</span><span class="p">,</span> <span class="n">new_headers</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">new_xdata</span><span class="p">,</span> <span class="n">flag</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;arguments are not valid&quot;</span><span class="p">)</span>
        <span class="c1"># all accepted flags with this method are already taken care of</span>
        <span class="c1"># flag argument is either not a flag or not one accepted by this method</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;flag must be &#39;global&#39;, &#39;dim_chg&#39;, &#39;dim_insert&#39;, &quot;</span>
                        <span class="s2">&quot;&#39;dim_rm&#39;, or &#39;dim_perm&#39;&quot;</span><span class="p">)</span></div>
        <span class="c1"># TODO : notify instead of returns</span>


<div class="viewcode-block" id="create_dimension_description"><a class="viewcode-back" href="../xdata.html#xdata.create_dimension_description">[docs]</a><span class="k">def</span> <span class="nf">create_dimension_description</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;the function creates an instance of DimensionDescription.</span>

<span class="sd">    create_dimension_description gives an instance of the class</span>
<span class="sd">    DimensionDescription from a label and an column of values of type</span>
<span class="sd">    pandas.core.series.Series.</span>

<span class="sd">    If column is None, the DimensionDescription instance will be of</span>
<span class="sd">    dimension_type &#39;mixed&#39; by default.</span>

<span class="sd">    When using this function, no unit is specified, so</span>
<span class="sd">    dimension_description.unit will be None.</span>

<span class="sd">    **Parameters**</span>

<span class="sd">    - label:</span>
<span class="sd">        label for the DimensionDescription instance</span>
<span class="sd">        (type str)</span>
<span class="sd">    - column:</span>
<span class="sd">        values to determine the dimension_type of the DimensionDescription</span>
<span class="sd">        (type pandas.core.series.Series, shape (n,1))</span>

<span class="sd">    **returns**</span>
<span class="sd">    DimensionDescription instance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;label must be of type str&quot;</span><span class="p">)</span>
    <span class="c1"># if no table of value is given:</span>
    <span class="k">if</span> <span class="n">column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">DimensionDescription</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="s1">&#39;mixed&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">series</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;column must be of type pandas.core.series.Series&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;column must be of shape (n,1)&quot;</span><span class="p">)</span>
    <span class="c1"># if a table of value is given, we must determine the dimension_type</span>
    <span class="c1"># we must check all the elements to make sure it is not a &#39;mixed&#39; type</span>
    <span class="n">dimension_type</span> <span class="o">=</span> <span class="n">DimensionDescription</span><span class="o">.</span><span class="n">infertype</span><span class="p">(</span><span class="n">column</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">not_mixed</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">not_mixed</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">column</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">dimension_type</span> <span class="o">==</span> <span class="n">DimensionDescription</span><span class="o">.</span><span class="n">infertype</span><span class="p">(</span><span class="n">column</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">not_mixed</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">not_mixed</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">DimensionDescription</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">dimension_type</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">DimensionDescription</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="s1">&#39;mixed&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="check_bank_unit"><a class="viewcode-back" href="../xdata.html#xdata.check_bank_unit">[docs]</a><span class="k">def</span> <span class="nf">check_bank_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The functions checks if this unit is in one of the conversion tables of</span>
<span class="sd">    the bank. If so, it returns the conversion table, else, it returns None</span>

<span class="sd">    **Parameters**</span>

<span class="sd">    - unit: type str, name of the unit</span>

<span class="sd">    **returns**</span>
<span class="sd">    a conversion table for the given unit if it exists in the bank</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO</span>
    <span class="k">return</span> <span class="p">[]</span></div>


<span class="k">def</span> <span class="nf">disp</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;generic disp method&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">pprint</span><span class="p">(</span><span class="nb">vars</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">pprint</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">MeasureHeader</span><span class="p">(</span><span class="s1">&#39;toto&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">)</span>


</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/xplor.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Xplor your data</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Elodie Ikkache, Thomas Deneux.
      Last updated on Jul 19, 2017.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.1.
    </div>
  </body>
</html>